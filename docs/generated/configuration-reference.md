# Stacks Node Configuration Reference

This document provides a comprehensive reference for all configuration options available in the Stacks node TOML configuration file.

The configuration is automatically generated from the Rust source code documentation.

## Table of Contents

- [[initial_balances]](#initial_balances)
- [[event_observer]](#event_observer)
- [[connection_options]](#connection_options)
- [[fee_estimation]](#fee_estimation)
- [[burnchain]](#burnchain)
- [[node]](#node)
- [[miner]](#miner)

## [initial_balances]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="initial_balances-address">address</span>](#initial_balances-address) | The Stacks address to receive the initial STX balance.<br>Must be a valid "non-mainnet" Stacks address (e.g., "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2"). | **Required** |
| [<span id="initial_balances-amount">amount</span>](#initial_balances-amount) | The amount of microSTX to allocate to the address at node startup.<br>1 STX = 1,000,000 microSTX.<br><br>**Units:** microSTX | **Required** |


## [event_observer]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="event_observer-disable_retries">disable_retries</span>](#event_observer-disable_retries) | Controls whether the node should retry sending event notifications if delivery fails or times out.<br><br>- If `false` (default): The node will attempt to deliver event notifications persistently.<br>  If an attempt fails (due to network error, timeout, or a non-200 HTTP response), the event<br>  payload is saved and retried indefinitely. This ensures that all events will eventually be<br>  delivered. However, this can cause the node's block processing to stall if an observer is<br>  down, or indefinitely fails to process the event.<br><br>- If `true`: The node will make only a single attempt to deliver each event notification.<br>  If this single attempt fails for any reason, the event is discarded, and no further retries<br>  will be made for that specific event.<br><br>**Notes:**<br>- **Warning:** Setting this to `true` can lead to missed events if the observer endpoint is temporarily unavailable or experiences issues. | `false` (retries are enabled) |
| [<span id="event_observer-endpoint">endpoint</span>](#event_observer-endpoint) | URL endpoint (hostname and port) where event notifications will be sent via HTTP POST requests.<br><br>The node will automatically prepend `http://` to this endpoint and append the<br>specific event path (e.g., `/new_block`, `/new_mempool_tx`).<br>Therefore, this value should be specified as `hostname:port` (e.g., "localhost:3700").<br><br>This should point to a service capable of receiving and processing Stacks event data.<br><br>**Notes:**<br>- **Do NOT include the `http://` scheme in this configuration value.**<br><br>**Example:**<br><pre><code>endpoint = "localhost:3700"</code></pre> | **Required** |
| [<span id="event_observer-events_keys">events_keys</span>](#event_observer-events_keys) | List of event types that this observer is configured to receive.<br><br>Each string in the list specifies an event category or a specific event to subscribe to.<br>For an observer to receive any notifications, this list must contain at least one valid key.<br>Providing an invalid string that doesn't match any of the valid formats below will cause<br>the node to panic on startup when parsing the configuration.<br><br>All observers, regardless of their `events_keys` configuration, implicitly receive<br>payloads on the `/attachments/new` endpoint.<br><br>Valid Event Keys:<br>- `"*"`: Subscribes to a broad set of common events.<br>&nbsp;&nbsp;- Events delivered to:<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_block`: For blocks containing transactions that generate STX, FT, NFT, or smart contract events.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_microblocks`: For all new microblock streams. Note: Only until epoch 2.5.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_mempool_tx`: For new mempool transactions.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/drop_mempool_tx`: For dropped mempool transactions.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_burn_block`: For new burnchain blocks.<br>&nbsp;&nbsp;- Note: This key does NOT by itself subscribe to `/stackerdb_chunks` or `/proposal_response`.<br><br>- `"stx"`: Subscribes to STX token operation events (transfer, mint, burn, lock).<br>&nbsp;&nbsp;- Events delivered to: `/new_block`, `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details: The "events" array in the delivered payloads will be filtered to include only STX-related events.<br><br>- `"memtx"`: Subscribes to new and dropped mempool transaction events.<br>&nbsp;&nbsp;- Events delivered to: `/new_mempool_tx`, `/drop_mempool_tx`.<br><br>- `"burn_blocks"`: Subscribes to new burnchain block events.<br>&nbsp;&nbsp;- Events delivered to: `/new_burn_block`.<br><br>- `"microblocks"`: Subscribes to new microblock stream events.<br>&nbsp;&nbsp;- Events delivered to: `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details:<br>&nbsp;&nbsp;&nbsp;&nbsp;- The "transactions" field will contain all transactions from the microblocks.<br>&nbsp;&nbsp;&nbsp;&nbsp;- The "events" field will contain STX, FT, NFT, or specific smart contract events<br>      *only if* this observer is also subscribed to those more specific event types<br>      (e.g., via `"stx"`, `"*"`, a specific contract event key, or a specific asset identifier key).<br>&nbsp;&nbsp;- Note: Only until epoch 2.5.<br><br>- `"stackerdb"`: Subscribes to StackerDB chunk update events.<br>&nbsp;&nbsp;- Events delivered to: `/stackerdb_chunks`.<br><br>- `"block_proposal"`: Subscribes to block proposal response events (for Nakamoto consensus).<br>&nbsp;&nbsp;- Events delivered to: `/proposal_response`.<br><br>- Smart Contract Event: Subscribes to a specific smart contract event.<br>&nbsp;&nbsp;- Format: `"{contract_address}.{contract_name}::{event_name}"`<br>    (e.g., `ST0000000000000000000000000000000000000000.my-contract::my-custom-event`)<br>&nbsp;&nbsp;- Events delivered to: `/new_block`, `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details: The "events" array in the delivered payloads will be filtered for this specific event.<br><br>- Asset Identifier for FT/NFT Events: Subscribes to events (mint, burn, transfer) for a specific Fungible Token (FT) or Non-Fungible Token (NFT).<br>&nbsp;&nbsp;- Format: `"{contract_address}.{contract_name}.{asset_name}"`<br>    (e.g., for an FT: `ST0000000000000000000000000000000000000000.my-ft-contract.my-fungible-token`)<br>&nbsp;&nbsp;- Events delivered to: `/new_block`, `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details: The "events" array in the delivered payloads will be filtered for events related to the specified asset.<br><br>**Notes:**<br>- For a more detailed documentation check the event-dispatcher docs in the `/docs` folder.<br><br>**Example:**<br><pre><code>events_keys = [&#10;  "burn_blocks",&#10;  "memtx",&#10;  "ST0000000000000000000000000000000000000000.my-contract::my-custom-event",&#10;  "ST0000000000000000000000000000000000000000.token-contract.my-ft"&#10;]</code></pre> | **Required** |
| [<span id="event_observer-timeout_ms">timeout_ms</span>](#event_observer-timeout_ms) | Maximum duration (in milliseconds) to wait for the observer endpoint to respond.<br><br>When the node sends an event notification to this observer, it will wait at most this long<br>for a successful HTTP response (status code 200) before considering the request timed out.<br>If a timeout occurs and retries are enabled (see `EventObserverConfig::disable_retries`),<br>the request will be attempted again according to the retry strategy.<br><br>**Units:** milliseconds | `1_000` |


## [connection_options]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="connection_options-auth_token">auth_token</span>](#connection_options-auth_token) | HTTP auth password to use when communicating with stacks-signer binary.<br><br>This token is used in the `Authorization` header for certain requests.<br>Primarily, it secures the communication channel between this node and a connected<br>`stacks-signer` instance.<br><br>It is also used to authenticate requests to `/v2/blocks?broadcast=1`.<br><br>**Notes:**<br>- **Requirement:** This field **must** be configured if the node needs to receive block proposals from a configured `stacks-signer` event_observer via the `/v3/block_proposal` endpoint. The value must match the token configured on the signer. | `None` (authentication disabled for relevant endpoints) |
| [<span id="connection_options-block_proposal_max_age_secs">block_proposal_max_age_secs</span>](#connection_options-block_proposal_max_age_secs) | Maximum age (in seconds) allowed for a block proposal received via the `/v3/block_proposal` RPC endpoint.<br><br>If a block proposal is received whose timestamp is older than<br>the current time minus this configured value, the node will reject the proposal<br>with an HTTP 422 (Unprocessable Entity) error, considering it too stale.<br>This prevents the node from spending resources validating outdated proposals.<br><br>**Units:** seconds | `600` |
| [<span id="connection_options-connect_timeout">connect_timeout</span>](#connection_options-connect_timeout) | Maximum duration (in seconds) a connection attempt is allowed to remain in the connecting state.<br><br>This applies to both incoming P2P and HTTP connections. If a remote peer initiates a connection<br>but does not complete the connection process (e.g., handshake for P2P) within this time, the node<br>will consider it unresponsive and drop the connection attempt.<br><br>**Units:** seconds | `10` |
| [<span id="connection_options-disable_block_download">disable_block_download</span>](#connection_options-disable_block_download) | If true, completely disables the block download state machine.<br><br>The node will not attempt to download Stacks blocks (neither Nakamoto tenures nor<br>legacy blocks) from peers.<br><br>**Notes:**<br>- Intended for testing or specialized node configurations. | `false` |
| [<span id="connection_options-disable_inbound_handshakes">disable_inbound_handshakes</span>](#connection_options-disable_inbound_handshakes) | If true, prevents the node from processing initial handshake messages from new inbound P2P connections.<br><br>This effectively stops the node from establishing new authenticated inbound P2P sessions.<br>Outbound connections initiated by this node are unaffected.<br><br>**Notes:**<br>- Primarily intended for testing purposes. | `false` |
| [<span id="connection_options-disable_inbound_walks">disable_inbound_walks</span>](#connection_options-disable_inbound_walks) | If true, disables the neighbor discovery mechanism from starting walks from inbound peers.<br>Walks will only initiate from seed/bootstrap peers, outbound connections, or pingbacks.<br><br>**Notes:**<br>- Primarily intended for testing or specific network debugging scenarios. | `false` |
| [<span id="connection_options-dns_timeout">dns_timeout</span>](#connection_options-dns_timeout) | Maximum time (in milliseconds) to wait for a DNS query to resolve.<br><br>When the node needs to resolve a hostname (e.g., from a peer's advertised `data_url`<br>or an Atlas attachment URL) into an IP address, it initiates a DNS lookup.<br>This setting defines the maximum duration the node will wait for the DNS server<br>to respond before considering the lookup timed out.<br><br>**Units:** milliseconds | `15_000` (15 seconds) |
| [<span id="connection_options-force_disconnect_interval">force_disconnect_interval</span>](#connection_options-force_disconnect_interval) | Fault injection setting for testing purposes. Interval (in seconds) for forced disconnection of all peers.<br><br>If set to a positive value, the node will periodically disconnect all of its P2P peers at<br>roughly this interval. This simulates network churn or partitioning for testing node resilience.<br><br>**Notes:**<br>- The code enforcing this behavior is conditionally compiled using `cfg!(test)` and is only active during test runs.<br>- This setting has no effect in standard production builds.<br><br>**Units:** seconds | `None` (feature disabled) |
| [<span id="connection_options-handshake_timeout">handshake_timeout</span>](#connection_options-handshake_timeout) | Maximum duration (in seconds) a P2P peer is allowed after connecting before completing the handshake.<br><br>If a P2P peer connects successfully but fails to send the necessary handshake messages<br>within this time, the node will consider it unresponsive and drop the connection.<br><br>**Units:** seconds | `5` |
| [<span id="connection_options-heartbeat">heartbeat</span>](#connection_options-heartbeat) | Interval (in seconds) at which this node expects to send or receive P2P keep-alive messages.<br><br>During the P2P handshake, this node advertises this configured `heartbeat` value to its peers.<br>Each peer uses the other's advertised heartbeat interval (plus a timeout margin) to monitor<br>responsiveness and detect potential disconnections. This node also uses its own configured<br>value to proactively send Ping messages if the connection would otherwise be idle, helping to<br>keep it active.<br><br>**Units:** seconds | `3_600` (1 hour) |
| [<span id="connection_options-idle_timeout">idle_timeout</span>](#connection_options-idle_timeout) | Maximum idle time (in seconds) for HTTP connections.<br><br>This applies only to HTTP connections. It defines the maximum allowed time since the<br>last response was sent by the node to the client. An HTTP connection is dropped if<br>both this `idle_timeout` and the general [timeout](#connection_options-timeout)  (time since last<br>request received) are exceeded.<br><br>**Units:** seconds | `15` |
| [<span id="connection_options-inbox_maxlen">inbox_maxlen</span>](#connection_options-inbox_maxlen) | Maximum number of messages allowed in the per-connection incoming buffer.<br>The limits apply individually to each established connection (both P2P and HTTP). | `100` |
| [<span id="connection_options-inv_reward_cycles">inv_reward_cycles</span>](#connection_options-inv_reward_cycles) | Lookback depth (in PoX reward cycles) for Nakamoto inventory synchronization requests.<br><br>When initiating an inventory sync cycle with a peer, the node requests data starting<br>from `inv_reward_cycles` cycles before the current target reward cycle. This determines<br>how much historical inventory information is requested in each sync attempt.<br><br>**Units:** PoX reward cycles | - `3` if [[burnchain].mode](#burnchain-mode)  is `"mainnet"`<br>- `6` otherwise |
| [<span id="connection_options-inv_sync_interval">inv_sync_interval</span>](#connection_options-inv_sync_interval) | Minimum interval (in seconds) between initiating inventory synchronization attempts with the same peer.<br><br>Acts as a per-peer cooldown to throttle sync requests. A new sync cycle with a peer generally<br>starts only after this interval has passed since the previous attempt began *and* the previous<br>cycle is considered complete.<br><br>**Units:** seconds | `45` |
| [<span id="connection_options-log_neighbors_freq">log_neighbors_freq</span>](#connection_options-log_neighbors_freq) | Frequency (in milliseconds) for logging the current P2P neighbor list at the DEBUG level.<br><br>If set to a non-zero value, the node will periodically log details about its currently<br>established P2P connections (neighbors). Setting this to 0 disables this periodic logging.<br><br>**Units:** milliseconds | `60_000` (1 minute) |
| [<span id="connection_options-max_http_clients">max_http_clients</span>](#connection_options-max_http_clients) | Maximum total number of allowed concurrent HTTP connections.<br><br>This limits the total number of simultaneous connections the node's RPC/HTTP server<br>will accept. If this limit is reached, new incoming HTTP connection attempts<br>will be rejected. | `1000` |
| [<span id="connection_options-max_inflight_attachments">max_inflight_attachments</span>](#connection_options-max_inflight_attachments) | Maximum number of concurrent Atlas data attachment download requests allowed.<br><br>This limits how many separate download requests for Atlas data attachments<br>can be active simultaneously. Helps manage network resources when fetching<br>potentially large attachment data. | `6` |
| [<span id="connection_options-max_inflight_blocks">max_inflight_blocks</span>](#connection_options-max_inflight_blocks) | Maximum number of concurrent Nakamoto block download requests allowed.<br><br>This limits how many separate block download processes for Nakamoto tenures<br>(both confirmed and unconfirmed) can be active simultaneously. Helps manage<br>network bandwidth and processing load during chain synchronization. | `6` |
| [<span id="connection_options-max_sockets">max_sockets</span>](#connection_options-max_sockets) | Maximum total number of concurrent network sockets the node is allowed to manage.<br><br>This limit applies globally to all types of sockets handled by the node's networking layer,<br>including listening sockets (P2P and RPC/HTTP), established P2P connections (inbound/outbound),<br>and established HTTP connections.<br>It serves as a hard limit to prevent the node from exhausting operating system<br>resources related to socket descriptors. | `800` |
| [<span id="connection_options-maximum_call_argument_size">maximum_call_argument_size</span>](#connection_options-maximum_call_argument_size) | Maximum size (in bytes) of the HTTP request body for read-only contract calls.<br><br>This limit is enforced on the `Content-Length` of incoming requests to the<br>`/v2/contracts/call-read-only/...` RPC endpoint. It prevents excessively large<br>request bodies, which might contain numerous or very large hex-encoded function arguments,<br>from overwhelming the node.<br><br>**Notes:**<br>- Calculated as 20 * `clarity::vm::types::BOUND_VALUE_SERIALIZATION_HEX`.<br><br>**Units:** bytes | `83_886_080` (80 MiB) |
| [<span id="connection_options-num_clients">num_clients</span>](#connection_options-num_clients) | Maximum number of allowed concurrent inbound P2P connections.<br><br>This acts as a hard limit. If the node already has this many active inbound P2P<br>connections, any new incoming P2P connection attempts will be rejected.<br>Outbound P2P connections initiated by this node are not counted against this limit. | `750` |
| [<span id="connection_options-num_neighbors">num_neighbors</span>](#connection_options-num_neighbors) | Target number of peers for StackerDB replication.<br><br>Sets the maximum number of potential replication target peers requested from the<br>StackerDB control contract (`get-replication-targets`) when configuring a replica.<br><br>Note: Formerly (pre-Epoch 3.0), this also controlled the target peer count for<br>inventory synchronization. | `32` |
| [<span id="connection_options-outbox_maxlen">outbox_maxlen</span>](#connection_options-outbox_maxlen) | Maximum number of messages allowed in the per-connection outgoing buffer.<br>The limit applies individually to each established connection (both P2P and HTTP). | `100` |
| [<span id="connection_options-private_key_lifetime">private_key_lifetime</span>](#connection_options-private_key_lifetime) | Validity duration (in number of bitcoin blocks) for the node's P2P session private key.<br><br>The node uses a temporary private key for signing P2P messages. This key has an associated<br>expiry bitcoin block height stored in the peer database. When the current bitcoin height<br>reaches or exceeds the key's expiry height, the node automatically generates a new random<br>private key.<br>The expiry block height for this new key is calculated by adding the configured<br>[private_key_lifetime](#connection_options-private_key_lifetime)  (in blocks) to the previous key's expiry block height.<br>The node then re-handshakes with peers to transition to the new key.<br>This provides periodic key rotation for P2P communication.<br><br>**Units:** bitcoin blocks | `9223372036854775807` (i64::MAX, effectively infinite, disabling automatic re-keying). |
| [<span id="connection_options-private_neighbors">private_neighbors</span>](#connection_options-private_neighbors) | Whether to allow connections and interactions with peers having private IP addresses.<br><br>If `false` (default), the node will generally:<br>- Reject incoming connection attempts from peers with private IPs.<br>- Avoid initiating connections to peers known to have private IPs.<br>- Ignore peers with private IPs during neighbor discovery (walks).<br>- Skip querying peers with private IPs for mempool or StackerDB data.<br>- Filter out peers with private IPs from API responses listing potential peers.<br><br>Setting this to `true` disables these restrictions, which can be useful for local testing<br>environments or fully private network deployments. | `false` |
| [<span id="connection_options-public_ip_address">public_ip_address</span>](#connection_options-public_ip_address) | The Public IPv4 address and port (e.g. "203.0.113.42:20444") to advertise to other nodes.<br><br>If this option is not set (`None`), the node will attempt to automatically discover its<br>public IP address. | `None` (triggers automatic discovery attempt) |
| [<span id="connection_options-read_only_call_limit_read_count">read_only_call_limit_read_count</span>](#connection_options-read_only_call_limit_read_count) | Maximum number of distinct read operations from Clarity data space allowed during a read-only call. | `30` |
| [<span id="connection_options-read_only_call_limit_read_length">read_only_call_limit_read_length</span>](#connection_options-read_only_call_limit_read_length) | Maximum total size (in bytes) of data allowed to be read from Clarity data space (variables, maps)<br>during a read-only call.<br><br>**Units:** bytes | `100_000` (100 KB). |
| [<span id="connection_options-read_only_call_limit_runtime">read_only_call_limit_runtime</span>](#connection_options-read_only_call_limit_runtime) | Runtime cost limit for an individual read-only function call. This represents<br>computation effort within the Clarity VM.<br>(See SIP-006: https://github.com/stacksgov/sips/blob/main/sips/sip-006/sip-006-runtime-cost-assessment.md)<br><br>**Units:** Clarity VM cost units | `1_000_000_000` |
| [<span id="connection_options-read_only_call_limit_write_count">read_only_call_limit_write_count</span>](#connection_options-read_only_call_limit_write_count) | Maximum number of distinct write operations allowed during a read-only call.<br><br>**Notes:**<br>- This limit is effectively forced to 0 by the API handler, ensuring read-only behavior.<br>- Configuring a non-zero value has no effect on read-only call execution. | `0` |
| [<span id="connection_options-read_only_call_limit_write_length">read_only_call_limit_write_length</span>](#connection_options-read_only_call_limit_write_length) | Maximum total size (in bytes) of data allowed to be written during a read-only call.<br><br>**Notes:**<br>- This limit is effectively forced to 0 by the API handler, ensuring read-only behavior.<br>- Configuring a non-zero value has no effect on read-only call execution.<br><br>**Units:** bytes | `0` |
| [<span id="connection_options-reject_blocks_pushed">reject_blocks_pushed</span>](#connection_options-reject_blocks_pushed) | Controls whether the node accepts Nakamoto blocks pushed proactively by peers.<br><br>- If `true`: Pushed blocks are ignored (logged at DEBUG and discarded). The node will<br>  still process blocks that it actively downloads.<br>- If `false`: Both pushed blocks and actively downloaded blocks are processed. | `false` |
| [<span id="connection_options-soft_max_clients_per_host">soft_max_clients_per_host</span>](#connection_options-soft_max_clients_per_host) | Soft limit on the number of inbound P2P connections allowed per host IP address.<br><br>During inbound connection pruning (when total inbound connections > [soft_num_clients](#connection_options-soft_num_clients) ),<br>the node checks if any single IP address has more connections than this limit.<br>If so, it preferentially prunes the newest connections originating from that<br>specific IP address until its count is reduced to this limit.<br>This prevents a single host from dominating the node's inbound connection capacity. | `4` |
| [<span id="connection_options-soft_max_neighbors_per_org">soft_max_neighbors_per_org</span>](#connection_options-soft_max_neighbors_per_org) | Soft limit on the number of outbound P2P connections per network organization (ASN).<br><br>During connection pruning (when total outbound connections > [soft_num_neighbors](#connection_options-soft_num_neighbors) ),<br>the node checks if any single network organization (identified by ASN) has more<br>outbound connections than this limit. If so, it preferentially prunes the least<br>healthy/newest connections from that overrepresented organization until its count<br>is reduced to this limit or the total outbound count reaches<br>[soft_num_neighbors](#connection_options-soft_num_neighbors) . This encourages connection diversity across<br>different network providers. | `32` |
| [<span id="connection_options-soft_num_clients">soft_num_clients</span>](#connection_options-soft_num_clients) | Soft limit threshold for triggering inbound P2P connection pruning.<br><br>If the total number of currently active inbound P2P connections exceeds this value,<br>the node will activate pruning logic to reduce the count, typically by applying<br>per-host limits (see [soft_max_clients_per_host](#connection_options-soft_max_clients_per_host) ).<br>This helps manage the overall load from inbound peers. | `750` |
| [<span id="connection_options-soft_num_neighbors">soft_num_neighbors</span>](#connection_options-soft_num_neighbors) | Target number of outbound P2P connections the node aims to maintain.<br><br>The connection pruning logic only activates if the current number of established<br>outbound P2P connections exceeds this value. Pruning aims to reduce the connection<br>count back down to this target, ensuring the node maintains a baseline number<br>of outbound peers for network connectivity. | `16` |
| [<span id="connection_options-stackerdb_hint_replicas">stackerdb_hint_replicas</span>](#connection_options-stackerdb_hint_replicas) | Static list of preferred replica peers for specific StackerDB contracts, provided as a JSON string.<br><br>This allows manually specifying known peers to use for replicating particular StackerDBs,<br>potentially overriding or supplementing the peers discovered via the StackerDB's control contract.<br><br>Format: The configuration value must be a TOML string containing valid JSON.<br>The JSON structure must be an array of tuples, where each tuple pairs a contract identifier<br>with a list of preferred neighbor addresses:<br>`[[ContractIdentifier, [NeighborAddress, ...]], ...]`<br><br>1.  `ContractIdentifier`: A JSON object representing the `QualifiedContractIdentifier`.<br>    It must have the specific structure:<br>    `{"issuer": [version_byte, [byte_array_20]], "name": "contract-name"}`<br><br>2.  `NeighborAddress`: A JSON object specifying the peer details:<br>    `{"ip": "...", "port": ..., "public_key_hash": "..."}`<br><br>**Notes:**<br>- Use this option with caution, primarily for advanced testing or bootstrapping.<br><br>**Example:**<br><pre><code>stackerdb_hint_replicas = '''&#10;[&#10;  [&#10;    {&#10;      "issuer": [1, [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]],&#10;      "name": "my-contract"&#10;    },&#10;    [&#10;      {&#10;        "ip": "192.0.2.1",&#10;        "port": 20444,&#10;        "public_key_hash": "0102030405060708090a0b0c0d0e0f1011121314"&#10;      }&#10;    ]&#10;  ]&#10;]&#10;'''</code></pre> | `None` (no hints provided) |
| [<span id="connection_options-timeout">timeout</span>](#connection_options-timeout) | General communication timeout (in seconds).<br><br>- For HTTP connections: Governs two timeout aspects:<br>&nbsp;&nbsp;- Server-side: Defines the maximum allowed time since the last request was received from a client.<br>    An idle connection is dropped if both this timeout and [idle_timeout](#connection_options-idle_timeout)  are exceeded.<br>&nbsp;&nbsp;- Client-side: Sets the timeout duration (TTL) for outgoing HTTP requests initiated by the node itself.<br>- For P2P connections: Used as the specific timeout for NAT punch-through requests.<br><br>**Units:** seconds | `15` |
| [<span id="connection_options-walk_interval">walk_interval</span>](#connection_options-walk_interval) | Minimum interval (in seconds) between the start of consecutive neighbor discovery walks.<br><br>The node periodically performs "neighbor walks" to discover new peers and maintain<br>an up-to-date view of the P2P network topology. This setting controls how frequently<br>these walks can be initiated, preventing excessive network traffic and processing.<br><br>**Units:** seconds | `60` |
| [<span id="connection_options-walk_seed_probability">walk_seed_probability</span>](#connection_options-walk_seed_probability) | Probability (0.0 to 1.0) of forcing a neighbor walk to start from a seed/bootstrap peer.<br><br>This probability applies only when the node is not in Initial Block Download (IBD)<br>and is already connected to at least one seed/bootstrap peer.<br>Normally, in this situation, the walk would start from a random inbound or outbound peer.<br>However, with this probability, the walk is forced to start from a seed peer instead.<br>This helps ensure the node periodically re-establishes its network view from trusted entry points. | `0.1` (10%) |
| ~~[<span id="connection_options-antientropy_public">antientropy_public</span>](#connection_options-antientropy_public)~~ | Controls whether a node with public inbound connections should still push blocks, even if not NAT'ed.<br><br>In the Stacks 2.x anti-entropy logic, if a node detected it had inbound connections<br>from public IPs (suggesting it wasn't behind NAT) and this flag was set to `false`,<br>it would refrain from proactively pushing blocks and microblocks to peers.<br>The assumption was that publicly reachable nodes should primarily serve downloads.<br>If set to `true` (default), the node would push data regardless of its perceived reachability.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. | `true` |
| ~~[<span id="connection_options-antientropy_retry">antientropy_retry</span>](#connection_options-antientropy_retry)~~ | Minimum interval (in seconds) between attempts to run the Epoch 2.x anti-entropy data push mechanism.<br><br>The Stacks 2.x anti-entropy protocol involves the node proactively pushing its known<br>Stacks blocks and microblocks to peers. This value specifies the cooldown period for this operation.<br>This prevents the node from excessively attempting to push data to its peers.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+.<br><br>**Units:** seconds | `3_600` (1 hour) |
| ~~[<span id="connection_options-download_interval">download_interval</span>](#connection_options-download_interval)~~ | Minimum interval (in seconds) between consecutive block download scans in epoch 2.x.<br><br>In the pre-Nakamoto block download logic, if a full scan for blocks completed without<br>finding any new blocks to download, and if the known peer inventories had not changed,<br>the node would wait at least this duration before initiating the next download scan.<br>This throttled the downloader when the node was likely already synchronized.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+.<br><br>**Units:** seconds | `10` |
| ~~[<span id="connection_options-full_inv_sync_interval">full_inv_sync_interval</span>](#connection_options-full_inv_sync_interval)~~ | Deprecated: it does not have any effect on the node's behavior.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `None` |
| ~~[<span id="connection_options-max_clients_per_host">max_clients_per_host</span>](#connection_options-max_clients_per_host)~~ | Maximum number of inbound p2p connections per host we permit.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `4` |
| ~~[<span id="connection_options-max_neighbors_per_host">max_neighbors_per_host</span>](#connection_options-max_neighbors_per_host)~~ | Maximum number of neighbors per host we permit.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `1` |
| ~~[<span id="connection_options-soft_max_neighbors_per_host">soft_max_neighbors_per_host</span>](#connection_options-soft_max_neighbors_per_host)~~ | Soft limit on the number of neighbors per host we permit.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `1` |


## [fee_estimation]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="fee_estimation-cost_estimator">cost_estimator</span>](#fee_estimation-cost_estimator) | Specifies the name of the cost estimator to use.<br>This controls how the node estimates computational costs for transactions.<br><br>Accepted values:<br>- `"NaivePessimistic"`: The only currently supported cost estimator. This estimator<br>  tracks the highest observed costs for each operation type and uses the average<br>  of the top 10 values as its estimate, providing a conservative approach to<br>  cost estimation.<br><br>**Notes:**<br>- If [disabled](#fee_estimation-disabled)  is `true`, the node will use the default unit cost estimator. | `"NaivePessimistic"` |
| [<span id="fee_estimation-cost_metric">cost_metric</span>](#fee_estimation-cost_metric) | Specifies the name of the cost metric to use.<br>This controls how the node measures and compares transaction costs.<br><br>Accepted values:<br>- `"ProportionDotProduct"`: The only currently supported cost metric. This metric<br>  computes a weighted sum of cost dimensions (runtime, read/write counts, etc.)<br>  proportional to how much of the block limit they consume.<br><br>**Notes:**<br>- If [disabled](#fee_estimation-disabled)  is `true`, the node will use the default unit cost metric. | `"ProportionDotProduct"` |
| [<span id="fee_estimation-disabled">disabled</span>](#fee_estimation-disabled) | If `true`, all fee and cost estimation features are disabled.<br>The node will use unit estimators and metrics, which effectively<br>provide no actual estimation capabilities.<br><br>When disabled, the node will:<br>1. Not track historical transaction costs or fee rates<br>2. Return simple unit values for costs for any transaction, regardless of its actual complexity<br>3. Be unable to provide meaningful fee estimates for API requests (always returns an error)<br>4. Consider only raw transaction fees (not fees per cost unit) when assembling blocks<br><br>This setting takes precedence over individual estimator/metric configurations.<br><br>**Notes:**<br>- When `true`, the values for [cost_estimator](#fee_estimation-cost_estimator) , [fee_estimator](#fee_estimation-fee_estimator) , and [cost_metric](#fee_estimation-cost_metric)  are ignored. | `false` |
| [<span id="fee_estimation-fee_estimator">fee_estimator</span>](#fee_estimation-fee_estimator) | Specifies the name of the fee estimator to use.<br>This controls how the node calculates appropriate transaction fees based on costs.<br><br>Accepted values:<br>- `"ScalarFeeRate"`: Simple multiplier-based fee estimation that uses percentiles<br>  (5th, 50th, and 95th) of observed fee rates from recent blocks.<br>- `"FuzzedWeightedMedianFeeRate"`: Fee estimation that adds controlled randomness<br>  to a weighted median rate calculator. This helps prevent fee optimization attacks<br>  by adding unpredictability to fee estimates while still maintaining accuracy.<br><br>**Notes:**<br>- If [disabled](#fee_estimation-disabled)  is `true`, the node will use the default unit fee estimator. | `"ScalarFeeRate"` |
| [<span id="fee_estimation-fee_rate_fuzzer_fraction">fee_rate_fuzzer_fraction</span>](#fee_estimation-fee_rate_fuzzer_fraction) | Specifies the fraction of random noise to add if using the `FuzzedWeightedMedianFeeRate` fee estimator.<br>This value should be in the range [0, 1], representing a percentage of the base fee rate.<br><br>For example, with a value of 0.1 (10%), fee rate estimates will have random noise added<br>within the range of ±10% of the original estimate. This randomization makes it difficult<br>for users to precisely optimize their fees while still providing reasonable estimates.<br><br>**Notes:**<br>- This setting is only relevant when [fee_estimator](#fee_estimation-fee_estimator)  is set to `"FuzzedWeightedMedianFeeRate"`. | `0.1` (10%) |
| [<span id="fee_estimation-fee_rate_window_size">fee_rate_window_size</span>](#fee_estimation-fee_rate_window_size) | Specifies the window size for the `WeightedMedianFeeRateEstimator`.<br>This determines how many historical fee rate data points are considered<br>when calculating the median fee rate.<br><br>The window size controls how quickly the fee estimator responds to changing<br>network conditions. A smaller window size (e.g., 5) makes the estimator more<br>responsive to recent fee rate changes but potentially more volatile. A larger<br>window size (e.g., 10) produces more stable estimates but may be slower to<br>adapt to rapid network changes.<br><br>**Notes:**<br>- This setting is primarily relevant when [fee_estimator](#fee_estimation-fee_estimator)  is set to `"FuzzedWeightedMedianFeeRate"`, as it's used by the underlying `WeightedMedianFeeRateEstimator`. | `5` |
| [<span id="fee_estimation-log_error">log_error</span>](#fee_estimation-log_error) | If `true`, errors encountered during cost or fee estimation will be logged.<br>This can help diagnose issues with the fee estimation subsystem. | `false` |


## [burnchain]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="burnchain-block_commit_tx_estimated_size">block_commit_tx_estimated_size</span>](#burnchain-block_commit_tx_estimated_size) | Estimated size (in virtual bytes) of a block commit transaction on bitcoin.<br>Used for fee calculation in mining logic by multiplying with the fee rate<br>[satoshis_per_byte](#burnchain-satoshis_per_byte) .<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** virtual bytes | `380` |
| [<span id="burnchain-burn_fee_cap">burn_fee_cap</span>](#burnchain-burn_fee_cap) | The maximum amount (in sats) of "burn commitment" to broadcast for the next block's leader election.<br>Acts as a safety cap to limit the maximum amount spent on mining.<br>It serves as both the target fee and a fallback if dynamic fee calculations fail or cannot be performed.<br><br>This setting can be hot-reloaded from the config file, allowing adjustment without restarting.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** satoshis | `20_000` |
| [<span id="burnchain-chain">chain</span>](#burnchain-chain) | The underlying blockchain used for Proof-of-Transfer.<br><br>**Notes:**<br>- Currently, only `"bitcoin"` is supported. | `"bitcoin"` |
| [<span id="burnchain-chain_id">chain_id</span>](#burnchain-chain_id) | The network-specific identifier used in P2P communication and database initialization.<br><br>**Notes:**<br>- **Warning:** Do not modify this unless you really know what you're doing.<br>- This is intended strictly for testing purposes. | - `0x00000001` if [mode](#burnchain-mode)  is `"mainnet"`<br>- `0x80000000` otherwise |
| [<span id="burnchain-commit_anchor_block_within">commit_anchor_block_within</span>](#burnchain-commit_anchor_block_within) | Specifies a mandatory wait period (in milliseconds) after receiving a burnchain tip<br>before the node attempts to build the anchored block for the new tenure.<br>This duration effectively schedules the start of the block-building<br>process relative to the tip's arrival time.<br><br>**Notes:**<br>- This is intended strictly for testing purposes.<br><br>**Units:** milliseconds | `5_000` |
| [<span id="burnchain-epochs">epochs</span>](#burnchain-epochs) | Custom override for the definitions of Stacks epochs (start/end burnchain heights, consensus rules).<br>This setting allows testing specific epoch transitions or custom consensus rules by defining exactly<br>when each epoch starts on bitcoin.<br><br>Epochs define distinct protocol rule sets (consensus rules, execution costs, capabilities).<br>When configured, the list must include all epochs sequentially from "1.0" up to the<br>highest desired epoch, without skipping any intermediate ones.<br>Valid `epoch_name` values currently include:<br>`"1.0"`, `"2.0"`, `"2.05"`, `"2.1"`, `"2.2"`, `"2.3"`, `"2.4"`, `"2.5"`, `"3.0"`, `"3.1"`.<br><br>**Validation Rules:**<br>- Epochs must be provided in strict chronological order (`1.0`, `2.0`, `2.05`...).<br>- `start_height` values must be non-decreasing across the list.<br>- Epoch `"1.0"` must have `start_height = 0`.<br>- The number of defined epochs cannot exceed the maximum supported by the node software.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Configured as a list `[[burnchain.epochs]]` in TOML, each with `epoch_name` (string) and `start_height` (integer Bitcoin block height).<br><br>**Example:**<br><pre><code>[[burnchain.epochs]]&#10;epoch_name = "2.1"&#10;start_height = 150&#10;&#10;[[burnchain.epochs]]&#10;epoch_name = "2.2"&#10;start_height = 200</code></pre> | `None` (uses the standard epoch definitions for the selected [mode](#burnchain-mode) ) |
| [<span id="burnchain-fault_injection_burnchain_block_delay">fault_injection_burnchain_block_delay</span>](#burnchain-fault_injection_burnchain_block_delay) | Fault injection setting for testing. Introduces an artificial delay (in milliseconds)<br>before processing each burnchain block download. Simulates a slow burnchain connection.<br><br>**Notes:**<br>- This is intended strictly for testing purposes.<br><br>**Units:** milliseconds | `0` (no delay) |
| [<span id="burnchain-first_burn_block_hash">first_burn_block_hash</span>](#burnchain-first_burn_block_hash) | Overrides the default starting block hash of the burnchain.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Should be used together with [first_burn_block_height](#burnchain-first_burn_block_height)  and [first_burn_block_timestamp](#burnchain-first_burn_block_timestamp)  for proper operation. | `None` (uses the burnchain's default starting block hash) |
| [<span id="burnchain-first_burn_block_height">first_burn_block_height</span>](#burnchain-first_burn_block_height) | Overrides the default starting bitcoin block height for the node.<br>Allows starting synchronization from a specific historical point in test environments.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Should be used together with [first_burn_block_timestamp](#burnchain-first_burn_block_timestamp)  and [first_burn_block_hash](#burnchain-first_burn_block_hash)  for proper operation. | `None` (uses the burnchain's default starting height for the mode) |
| [<span id="burnchain-first_burn_block_timestamp">first_burn_block_timestamp</span>](#burnchain-first_burn_block_timestamp) | Overrides the default starting block timestamp of the burnchain.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Should be used together with [first_burn_block_height](#burnchain-first_burn_block_height)  and [first_burn_block_hash](#burnchain-first_burn_block_hash)  for proper operation. | `None` (uses the burnchain's default starting timestamp) |
| [<span id="burnchain-leader_key_tx_estimated_size">leader_key_tx_estimated_size</span>](#burnchain-leader_key_tx_estimated_size) | Estimated size (in virtual bytes) of a leader key registration transaction on bitcoin.<br>Used for fee calculation in mining logic by multiplying with the fee rate<br>[satoshis_per_byte](#burnchain-satoshis_per_byte) .<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** virtual bytes | `290` |
| [<span id="burnchain-local_mining_public_key">local_mining_public_key</span>](#burnchain-local_mining_public_key) | The public key associated with the local mining address for the underlying Bitcoin regtest node.<br>Provided as a hex string representing an uncompressed public key.<br><br>It is primarily used in modes that rely on a controlled Bitcoin regtest backend<br>(e.g., "helium", "mocknet", "neon") where the Stacks node itself needs to<br>instruct the Bitcoin node to generate blocks.<br><br>The key is used to derive the Bitcoin address that receives the coinbase rewards<br>when generating blocks on the regtest network.<br><br>**Notes:**<br>- Mandatory if [mode](#burnchain-mode)  is "helium".<br>- This is intended strictly for testing purposes. | `None` |
| [<span id="burnchain-magic_bytes">magic_bytes</span>](#burnchain-magic_bytes) | The network "magic bytes" used to identify packets for the specific bitcoin network<br>instance (e.g., mainnet, testnet, regtest). Must match the magic bytes of the connected<br>bitcoin node.<br><br>These two-byte identifiers help ensure that nodes only connect to peers on the same<br>network type. Common values include:<br>- "X2" for mainnet<br>- "T2" for testnet (xenon)<br>- Other values for specific test networks<br><br>Configured as a 2-character ASCII string (e.g., "X2" for mainnet). | - `"T2"` if [mode](#burnchain-mode)  is `"xenon"`<br>- `"X2"` otherwise |
| [<span id="burnchain-max_rbf">max_rbf</span>](#burnchain-max_rbf) | Maximum fee rate multiplier allowed when using Replace-By-Fee (RBF) for bitcoin transactions.<br>Expressed as a percentage of the original [satoshis_per_byte](#burnchain-satoshis_per_byte)  rate (e.g.,<br>150 means the fee rate can be increased up to 1.5x). Used in mining logic for RBF decisions<br>to cap the replacement fee rate.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** percent | `150` |
| [<span id="burnchain-max_unspent_utxos">max_unspent_utxos</span>](#burnchain-max_unspent_utxos) | The maximum number of unspent transaction outputs (UTXOs) to request from the bitcoin node.<br><br>This value is passed as the `maximumCount` parameter to the bitcoin node. It helps manage<br>response size and processing load, particularly relevant for miners querying for available<br>UTXOs to fund operations like block commits or leader key registrations.<br><br>Setting this limit too high might lead to performance issues or timeouts when querying<br>nodes with a very large number of UTXOs. Conversely, setting it too low might prevent<br>the miner from finding enough UTXOs in a single query to meet the required funding amount<br>for a transaction, even if sufficient funds exist across more UTXOs not returned by the limited query.<br><br>**Notes:**<br>- This value must be `<= 1024`.<br>- Only relevant if [[node].miner](#node-miner)  is `true`. | `1024` |
| [<span id="burnchain-mode">mode</span>](#burnchain-mode) | The operational mode or network profile for the Stacks node.<br>This setting determines network parameters (like chain ID, peer version),<br>default configurations, genesis block definitions, and overall node behavior.<br><br>Supported values:<br>- `"mainnet"`: mainnet<br>- `"xenon"`: testnet<br>- `"mocknet"`: regtest<br>- `"helium"`: regtest<br>- `"neon"`: regtest<br>- `"argon"`: regtest<br>- `"krypton"`: regtest<br>- `"nakamoto-neon"`: regtest | `"mocknet"` |
| [<span id="burnchain-password">password</span>](#burnchain-password) | The password for authenticating with the bitcoin node's RPC interface.<br>Required if the bitcoin node requires RPC authentication.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`. | `None` |
| [<span id="burnchain-peer_host">peer_host</span>](#burnchain-peer_host) | The hostname or IP address of the bitcoin node peer.<br><br>This field is required for all node configurations as it specifies where to find the underlying<br>bitcoin node to interact with for PoX operations, block validation, and mining. | `"0.0.0.0"` |
| [<span id="burnchain-peer_port">peer_port</span>](#burnchain-peer_port) | The P2P network port of the bitcoin node specified by [peer_host](#burnchain-peer_host) . | `8333` |
| [<span id="burnchain-peer_version">peer_version</span>](#burnchain-peer_version) | The peer protocol version number used in P2P communication.<br>This parameter cannot be set via the configuration file.<br><br>**Notes:**<br>- **Warning:** Do not modify this unless you really know what you're doing. | - `402_653_196` if [mode](#burnchain-mode)  is `"mainnet"`<br>- `4_207_599_116` otherwise |
| [<span id="burnchain-poll_time_secs">poll_time_secs</span>](#burnchain-poll_time_secs) | The interval, in seconds, at which the node polls the bitcoin node for new blocks and state updates.<br><br>The default value of 10 seconds is mainly intended for testing purposes.<br>It's suggested to set this to a higher value for mainnet, e.g., 300 seconds (5 minutes).<br><br>**Units:** seconds | `10` |
| [<span id="burnchain-pox_2_activation">pox_2_activation</span>](#burnchain-pox_2_activation) | Sets a custom burnchain height for PoX-2 activation (for testing).<br><br>This affects two key transitions:<br>1. The block height at which PoX v1 lockups are automatically unlocked.<br>2. The block height from which PoX reward set calculations switch to PoX v2 rules.<br><br>**Behavior:**<br>- This value directly sets the auto unlock height for PoX v1 lockups before transition to PoX v2.<br>  This also defines the burn height at which PoX reward sets are calculated using PoX v2 rather than v1.<br>- If custom [epochs](#burnchain-epochs)  are provided:<br>&nbsp;&nbsp;- This value is used to validate that Epoch 2.1's start height is ≤ this value.<br>&nbsp;&nbsp;- However, the height specified in `epochs` for Epoch 2.1 takes precedence.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes. | `None` |
| [<span id="burnchain-pox_prepare_length">pox_prepare_length</span>](#burnchain-pox_prepare_length) | Overrides the length (in bitcoin blocks) of the PoX prepare phase.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br><br>**Units:** bitcoin blocks | `None` (uses the standard prepare phase length for the mode) |
| [<span id="burnchain-pox_reward_length">pox_reward_length</span>](#burnchain-pox_reward_length) | Overrides the length (in bitcoin blocks) of the PoX reward cycle.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br><br>**Units:** bitcoin blocks | `None` (uses the standard reward cycle length for the mode) |
| [<span id="burnchain-process_exit_at_block_height">process_exit_at_block_height</span>](#burnchain-process_exit_at_block_height) | Optional bitcoin block height at which the Stacks node process should gracefully exit.<br>When bitcoin reaches this height, the node logs a message and initiates a graceful shutdown.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes. | `None` |
| [<span id="burnchain-rbf_fee_increment">rbf_fee_increment</span>](#burnchain-rbf_fee_increment) | The incremental amount (in sats/vByte) to add to the previous transaction's<br>fee rate for RBF bitcoin transactions.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** sats/vByte | `5` |
| [<span id="burnchain-rpc_port">rpc_port</span>](#burnchain-rpc_port) | The RPC port of the bitcoin node specified by [peer_host](#burnchain-peer_host) . | `8332` |
| [<span id="burnchain-rpc_ssl">rpc_ssl</span>](#burnchain-rpc_ssl) | Flag indicating whether to use SSL/TLS when connecting to the bitcoin node's RPC interface. | `false` |
| [<span id="burnchain-satoshis_per_byte">satoshis_per_byte</span>](#burnchain-satoshis_per_byte) | The default fee rate in sats/vByte to use when estimating fees for miners<br>to submit bitcoin transactions (like block commits or leader key registrations).<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** sats/vByte | `50` |
| [<span id="burnchain-timeout">timeout</span>](#burnchain-timeout) | Timeout duration, in seconds, for RPC calls made to the bitcoin node.<br>Configures the timeout on the underlying HTTP client.<br><br>**Units:** seconds | `60` |
| [<span id="burnchain-username">username</span>](#burnchain-username) | The username for authenticating with the bitcoin node's RPC interface.<br>Required if the bitcoin node requires RPC authentication.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`. | `None` |
| [<span id="burnchain-wallet_name">wallet_name</span>](#burnchain-wallet_name) | Specifies the name of the Bitcoin wallet to use within the connected bitcoin node.<br>Used to interact with a specific named wallet if the bitcoin node manages multiple wallets.<br><br>If the specified wallet doesn't exist, the node will attempt to create it via the<br>`createwallet` RPC call. This is particularly useful for miners who need to manage<br>separate wallets.<br><br>**Notes:**<br>- Primarily relevant for miners interacting with multi-wallet Bitcoin nodes. | `""` (empty string, implying the default wallet or no specific wallet needed) |
| ~~[<span id="burnchain-affirmation_overrides">affirmation_overrides</span>](#burnchain-affirmation_overrides)~~ | Overrides for the burnchain block affirmation map for specific reward cycles.<br>Allows manually setting the miner affirmation ('p'resent/'n'ot-present/'a'bsent) map for a<br>given cycle, bypassing the map normally derived from sortition results.<br><br>Special defaults are added when [mode](#burnchain-mode)  is "xenon", but config entries take precedence.<br>At startup, these overrides are written to the `BurnchainDB` (`overrides` table).<br><br>**Notes:**<br>- Primarily used for testing or recovering from network issues.<br>- Configured as a list `[[burnchain.affirmation_overrides]]` in TOML, each with `reward_cycle` (integer) and `affirmation` (string of 'p'/'n'/'a', length `reward_cycle - 1`).<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Example:**<br><pre><code>[[burnchain.affirmation_overrides]]&#10;reward_cycle = 413&#10;affirmation = "pna..." # Must be 412 chars long</code></pre> | Empty map |
| ~~[<span id="burnchain-ast_precheck_size_height">ast_precheck_size_height</span>](#burnchain-ast_precheck_size_height)~~ | Override for the burnchain height activating stricter AST size checks pre-epoch 3.0 for testing purposes.<br><br>Used pre-epoch 3.0 to control activation before it became standard (at burn height `752000`).<br>Ignored in standard production builds as the underlying mechanism is disabled unless the `testing`<br>feature is active.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. | `None` |
| ~~[<span id="burnchain-sunset_end">sunset_end</span>](#burnchain-sunset_end)~~ | Overrides the bitcoin height, non-inclusive, at which the PoX sunset period ends in epochs before 2.1.<br>After this height, Stacking rewards are disabled completely. This parameter works together<br>with `sunset_start` to define the full sunset transition period for PoX.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br><br>**⚠️ DEPRECATED:** The sunset phase was removed in Epoch 2.1. This parameter can still be used for<br>testing purposes for epochs before 2.1. | `None` (uses the standard sunset end height for the mode) |
| ~~[<span id="burnchain-sunset_start">sunset_start</span>](#burnchain-sunset_start)~~ | Overrides the bitcoin height at which the PoX sunset period begins in epochs before 2.1.<br>The sunset period represents a planned phase-out of the PoX mechanism. During this period,<br>stacking rewards gradually decrease, eventually ceasing entirely. This parameter allows<br>testing the PoX sunset transition by explicitly setting its start height.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br><br>**⚠️ DEPRECATED:** The sunset phase was removed in Epoch 2.1. This parameter can still be used for<br>testing purposes for epochs before 2.1. | `None` (uses the standard sunset start height for the mode) |


## [node]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="node-always_use_affirmation_maps">always_use_affirmation_maps</span>](#node-always_use_affirmation_maps) | Controls if Stacks Epoch 2.1+ affirmation map logic should be applied even before Epoch 2.1.<br>- If `true` (default), the node consistently uses the newer (Epoch 2.1) rules for PoX anchor block<br>  validation and affirmation-based reorg handling, even in earlier epochs.<br>- If `false`, the node strictly follows the rules defined for the specific epoch it is currently<br>  processing, only applying 2.1+ logic from Epoch 2.1 onwards.<br>Differences in this setting between nodes prior to Epoch 2.1 could lead to consensus forks. | `true` |
| [<span id="node-assume_present_anchor_blocks">assume_present_anchor_blocks</span>](#node-assume_present_anchor_blocks) | Controls if the node must strictly wait for any PoX anchor block selected by the core consensus mechanism.<br>- If `true`: Halts burnchain processing immediately whenever a selected anchor block is missing locally<br>  (`SelectedAndUnknown` status), regardless of affirmation status. This is always true in Nakamoto (Epoch 3.0+)<br>  and runs *before* affirmation checks.<br>- If `false` (primarily for testing): Skips this immediate halt, allowing processing to proceed to<br>  affirmation map checks.<br>Normal operation requires this to be `true`; setting to `false` will likely break consensus adherence.<br><br>**Notes:**<br>- This parameter cannot be set via the configuration file; it must be modified programmatically. | `true` |
| [<span id="node-bootstrap_node">bootstrap_node</span>](#node-bootstrap_node) | A list of initial peer nodes used to bootstrap connections into the Stacks P2P network.<br>Peers are specified in a configuration file as comma-separated strings in the<br>format `"PUBKEY@IP:PORT"` or `"PUBKEY@HOSTNAME:PORT"`. DNS hostnames are resolved<br>during configuration loading.<br><br>**Example:**<br><pre><code>bootstrap_node = "pubkey1@example.com:30444,pubkey2@192.168.1.100:20444"</code></pre> | `[]` (empty vector) |
| [<span id="node-chain_liveness_poll_time_secs">chain_liveness_poll_time_secs</span>](#node-chain_liveness_poll_time_secs) | The polling interval, in seconds, for the background thread that monitors chain liveness.<br>This thread periodically wakes up the main coordinator to check for chain progress or<br>other conditions requiring action.<br><br>**Units:** seconds | `300` (5 minutes) |
| [<span id="node-data_url">data_url</span>](#node-data_url) | The publicly accessible URL that this node advertises to peers during the P2P handshake<br>as its HTTP RPC endpoint. Other nodes or services might use this URL to query the node's API. | `http://{rpc_bind}` (e.g., "http://0.0.0.0:20443" if [rpc_bind](#node-rpc_bind)  is default). |
| [<span id="node-deny_nodes">deny_nodes</span>](#node-deny_nodes) | A list of peer addresses that this node should explicitly deny connections from.<br>Peers are specified as comma-separated strings in the format "IP:PORT" or "HOSTNAME:PORT"<br>in the configuration file. DNS hostnames are resolved during configuration loading.<br><br>**Example:**<br><pre><code>deny_nodes = "192.168.1.100:20444,badhost.example.com:20444"</code></pre> | `[]` (empty vector) |
| [<span id="node-fault_injection_block_push_fail_probability">fault_injection_block_push_fail_probability</span>](#node-fault_injection_block_push_fail_probability) | Fault injection setting for testing purposes. If set to `Some(p)`, where `p` is between 0 and 100,<br>the node will have a `p` percent chance of intentionally *not* pushing a newly processed block<br>to its peers.<br><br>**Notes:**<br>- Values: 0-100 (percentage). | `None` (no fault injection) |
| [<span id="node-fault_injection_hide_blocks">fault_injection_hide_blocks</span>](#node-fault_injection_hide_blocks) | Fault injection setting for testing purposes. If `true`, the node's chainstate database<br>access layer may intentionally fail to retrieve block data, even if it exists,<br>simulating block hiding or data unavailability.<br><br>**Notes:**<br>- This parameter cannot be set via the configuration file; it must be modified programmatically. | `false` |
| [<span id="node-local_peer_seed">local_peer_seed</span>](#node-local_peer_seed) | The private key seed, provided as a hex string in the config file, used specifically for the<br>node's identity and message signing within the P2P networking layer.<br>This is separate from the main [seed](#node-seed) . | Randomly generated 32 bytes |
| [<span id="node-marf_cache_strategy">marf_cache_strategy</span>](#node-marf_cache_strategy) | The strategy to use for MARF trie node caching in memory.<br>Controls the trade-off between memory usage and performance for state access.<br><br>Possible values:<br>- `"noop"`: No caching (least memory).<br>- `"everything"`: Cache all nodes (most memory, potentially fastest).<br>- `"node256"`: Cache only larger `TrieNode256` nodes.<br><br>If the value is `None` or an unrecognized string, it defaults to `"noop"`. | `None` (effectively `"noop"`) |
| [<span id="node-marf_defer_hashing">marf_defer_hashing</span>](#node-marf_defer_hashing) | Controls the timing of hash calculations for MARF trie nodes.<br>- If `true`, hashes are calculated only when the MARF is flushed to disk (deferred hashing).<br>- If `false`, hashes are calculated immediately as leaf nodes are inserted or updated (immediate hashing).<br>Deferred hashing might improve write performance. | `true` |
| [<span id="node-miner">miner</span>](#node-miner) | Flag indicating whether this node should activate its mining logic and attempt to produce Stacks blocks.<br>Setting this to `true` typically requires providing necessary private keys (either [seed](#node-seed)  or<br>[[miner].mining_key](#miner-mining_key) ). It also influences default behavior for settings like<br>[require_affirmed_anchor_blocks](#node-require_affirmed_anchor_blocks) . | `false` |
| [<span id="node-mock_mining">mock_mining</span>](#node-mock_mining) | Enables a simulated mining mode, primarily for local testing and development.<br>When `true`, the node may generate blocks locally without participating in the<br>real bitcoin consensus or P2P block production process.<br><br>**Notes:**<br>- Only relevant if [miner](#node-miner)  is `true`. | `false` |
| [<span id="node-name">name</span>](#node-name) | Human-readable name for the node. Primarily used for identification in testing environments<br>(e.g., deriving log file names, temporary directory names). | `"helium-node"` |
| [<span id="node-next_initiative_delay">next_initiative_delay</span>](#node-next_initiative_delay) | Controls how frequently, in milliseconds, the Nakamoto miner's relay thread polls for work<br>or takes periodic actions when idle (e.g., checking for new burnchain blocks).<br>Default value of 10 seconds is reasonable in mainnet (where bitcoin blocks are ~10 minutes)<br>A lower value might be useful in other environments with faster burn blocks.<br><br>**Units:** milliseconds | `10_000` (10 seconds) |
| [<span id="node-p2p_address">p2p_address</span>](#node-p2p_address) | The publicly accessible IPv4 address and port that this node advertises to peers for P2P connections.<br>This might differ from [p2p_bind](#node-p2p_bind)  if the node is behind NAT or a proxy.<br><br>**Notes:**<br>- The default value derivation might be unexpected, potentially using the [rpc_bind](#node-rpc_bind)  address; explicit configuration is recommended if needed. | Derived from [rpc_bind](#node-rpc_bind)  (e.g., "0.0.0.0:20443" if [rpc_bind](#node-rpc_bind)  is default). |
| [<span id="node-p2p_bind">p2p_bind</span>](#node-p2p_bind) | The IPv4 address and port (e.g., "0.0.0.0:20444") on which the node's P2P networking<br>service should bind and listen for incoming connections from other peers. | `"0.0.0.0:20444"` |
| [<span id="node-prometheus_bind">prometheus_bind</span>](#node-prometheus_bind) | Optional network address and port (e.g., "127.0.0.1:9153") for binding the Prometheus metrics server.<br>If set, the node will start an HTTP server on this address to expose internal metrics<br>for scraping by a Prometheus instance. | `None` (Prometheus server disabled) |
| [<span id="node-require_affirmed_anchor_blocks">require_affirmed_anchor_blocks</span>](#node-require_affirmed_anchor_blocks) | Controls if the node must wait for locally missing but burnchain-affirmed PoX anchor blocks.<br>If an anchor block is confirmed by the affirmation map but not yet processed by this node:<br>- If `true`: Burnchain processing halts until the affirmed block is acquired. Ensures strict<br>  adherence to the affirmed canonical chain, typical for followers.<br>- If `false`: Burnchain processing continues without waiting. Allows miners to operate optimistically<br>  but may necessitate unwinding later if the affirmed block alters the chain state. | - `true` if [miner](#node-miner)  is `false`<br>- `false` if [miner](#node-miner)  is `true` |
| [<span id="node-rpc_bind">rpc_bind</span>](#node-rpc_bind) | The IPv4 address and port (e.g., "0.0.0.0:20443") on which the node's HTTP RPC server<br>should bind and listen for incoming API requests. | `"0.0.0.0:20443"` |
| [<span id="node-seed">seed</span>](#node-seed) | The node's Bitcoin wallet private key, provided as a hex string in the config file.<br>Used to initialize the node's keychain for signing operations.<br>If [[miner].mining_key](#miner-mining_key)  is not set, this seed may also be used for mining-related signing.<br><br>**Notes:**<br>- Required if [miner](#node-miner)  is `true` and [[miner].mining_key](#miner-mining_key)  is absent. | Randomly generated 32 bytes |
| [<span id="node-stacker">stacker</span>](#node-stacker) | Setting this to `true` enables the node to replicate the miner and signer Stacker DBs<br>required for signing, and is required if the node is connected to a signer. | `false` |
| [<span id="node-stacker_dbs">stacker_dbs</span>](#node-stacker_dbs) | A list of specific StackerDB contracts (identified by their qualified contract identifiers,<br>e.g., "SP000000000000000000002Q6VF78.pox-3") that this node should actively replicate.<br><br>**Notes:**<br>- Values are strings representing qualified contract identifiers.<br><br>**Example:**<br><pre><code>stacker_dbs = ["SP000000000000000000002Q6VF78.pox-3", "SP2C2YFP12AJZB4M4KUPSTMZQR0SNHNPH204SCQJM.stx-oracle-v1"]</code></pre> | - If [miner](#node-miner)  is `true` or [stacker](#node-stacker)  is `true`, relevant system contracts<br>  (like `.miners`, `.signers-*`) are automatically added in addition to any contracts<br>  specified in the configuration file.<br>- Otherwise, defaults to an empty list `[]` if not specified in the TOML. |
| [<span id="node-txindex">txindex</span>](#node-txindex) | Enables the transaction index, which maps transaction IDs to the blocks containing them.<br>Setting this to `true` allows the use of RPC endpoints that look up transactions by ID<br>(e.g., `/extended/v1/tx/{txid}`), but requires substantial additional disk space for the index database. | `false` |
| [<span id="node-use_test_genesis_chainstate">use_test_genesis_chainstate</span>](#node-use_test_genesis_chainstate) | If set to `true`, the node initializes its state using an alternative test genesis block definition,<br>loading different initial balances, names, and lockups than the standard network genesis.<br>This is intended strictly for testing purposes and is disallowed on mainnet.<br><br>**Notes:**<br>- This is intended strictly for testing purposes and is disallowed on mainnet. | `None` (uses standard network genesis) |
| [<span id="node-wait_time_for_blocks">wait_time_for_blocks</span>](#node-wait_time_for_blocks) | When operating as a miner, this specifies the maximum time (in milliseconds)<br>the node waits after detecting a new burnchain block to synchronize corresponding<br>Stacks block data from the network before resuming mining attempts.<br>If synchronization doesn't complete within this duration, mining resumes anyway<br>to prevent stalling. This setting is loaded by all nodes but primarily affects<br>miner behavior within the relayer thread.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |
| [<span id="node-working_dir">working_dir</span>](#node-working_dir) | The file system absolute path to the node's working directory.<br>All persistent data, including chainstate, burnchain databases, and potentially other stores,<br>will be located within this directory.<br>This path can be overridden by setting the `STACKS_WORKING_DIR` environment variable.<br><br>**Notes:**<br>- For persistent mainnet or testnet nodes, this path must be explicitly configured to a non-temporary location. | `/tmp/stacks-node-{current_timestamp}` |
| ~~[<span id="node-max_microblocks">max_microblocks</span>](#node-max_microblocks)~~ | The maximum number of microblocks allowed per Stacks block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+. | `65535` (u16::MAX) |
| ~~[<span id="node-microblock_frequency">microblock_frequency</span>](#node-microblock_frequency)~~ | How often to attempt producing microblocks, in milliseconds.<br><br>**Notes:**<br>- Only applies when [mine_microblocks](#node-mine_microblocks)  is true and before Epoch 2.5.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |
| ~~[<span id="node-mine_microblocks">mine_microblocks</span>](#node-mine_microblocks)~~ | Enable microblock mining.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+. | `true` |
| ~~[<span id="node-mock_mining_output_dir">mock_mining_output_dir</span>](#node-mock_mining_output_dir)~~ | If [mock_mining](#node-mock_mining)  is enabled, this specifies an optional directory path where the<br>generated mock Stacks blocks will be saved. (pre-Nakamoto)<br>The path is canonicalized on load.<br><br>**⚠️ DEPRECATED:** This setting was only used in the neon node and is ignored in Epoch 3.0+. | `None` |
| ~~[<span id="node-pox_sync_sample_secs">pox_sync_sample_secs</span>](#node-pox_sync_sample_secs)~~ | Sampling interval in seconds for the PoX synchronization watchdog thread (pre-Nakamoto).<br>Determines how often the watchdog checked PoX state consistency in the Neon run loop.<br><br>**⚠️ DEPRECATED:** Unused after the Nakamoto upgrade. This setting is ignored in Epoch 3.0+.<br><br>**Units:** seconds | `30` |
| ~~[<span id="node-wait_time_for_microblocks">wait_time_for_microblocks</span>](#node-wait_time_for_microblocks)~~ | Cooldown period after a microblock is produced, in milliseconds.<br><br>**Notes:**<br>- Only applies when [mine_microblocks](#node-mine_microblocks)  is true and before Epoch 2.5.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |


## [miner]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="miner-activated_vrf_key_path">activated_vrf_key_path</span>](#miner-activated_vrf_key_path) | Path to a file for storing and loading the currently active, registered VRF leader key.<br><br>Loading: On startup or when needing to register a key, if this path is set, the relayer first<br>attempts to load a serialized `RegisteredKey` from this file. If successful, it uses the<br>loaded key and skips the on-chain VRF key registration transaction, saving time and fees.<br>Saving: After a new VRF key registration transaction is confirmed and activated on the burnchain,<br>if this path is set, the node saves the details of the newly activated `RegisteredKey` to this file.<br>This allows the miner to persist its active VRF key across restarts.<br>If the file doesn't exist during load, or the path is `None`, the node proceeds with a new registration. | `None` |
| [<span id="miner-block_commit_delay">block_commit_delay</span>](#miner-block_commit_delay) | Time in milliseconds to wait for a Nakamoto block after seeing a burnchain block before submitting a block commit.<br><br>After observing a new burnchain block, the miner's relayer waits for this duration<br>before submitting its next block commit transaction to Bitcoin. This delay provides an opportunity<br>for a new Nakamoto block (produced by the winner of the latest sortition) to arrive.<br>Waiting helps avoid situations where the relayer immediately submits a commit that needs<br>to be replaced via RBF if a new Stacks block appears shortly after.<br>This delay is skipped if the new burnchain blocks leading to the tip contain no sortitions.<br><br>**Units:** milliseconds | `40_000` |
| [<span id="miner-block_rejection_timeout_steps">block_rejection_timeout_steps</span>](#miner-block_rejection_timeout_steps) | Defines adaptive timeouts for waiting for signer responses, based on the accumulated weight of rejections.<br><br>Configured as a map where keys represent rejection count thresholds in percentage,<br>and values are the timeout durations (in seconds) to apply when the rejection count<br>reaches or exceeds that key but is less than the next key.<br><br>When a miner proposes a block, it waits for signer responses (approvals or rejections).<br>The SignerCoordinator tracks the total weight of received rejections. It uses this map to determine<br>the current timeout duration. It selects the timeout value associated with the largest key<br>in the map that is less than or equal to the current accumulated rejection weight.<br>If this timeout duration expires before a decision is reached, the coordinator signals a timeout.<br>This prompts the miner to potentially retry proposing the block.<br>As more rejections come in, the applicable timeout step might change (likely decrease),<br>allowing the miner to abandon unviable proposals faster.<br><br>A key for 0 (zero rejections) must be defined, representing the initial timeout when no rejections have been received.<br><br>**Notes:**<br>- Keys are rejection weight percentages (0-100). Values are timeout durations.<br><br>**Example:**<br><pre><code># Keys are rejection counts (as strings), values are timeouts in seconds.&#10;[miner.block_rejection_timeout_steps]&#10;"0" = 180&#10;"10" = 90&#10;"20" = 45&#10;"30" = 0</code></pre> | `{ 0: 180, 10: 90, 20: 45, 30: 0 }` (times in seconds) |
| [<span id="miner-block_reward_recipient">block_reward_recipient</span>](#miner-block_reward_recipient) | Optional recipient for the coinbase block reward, overriding the default miner address.<br><br>By default (`None`), the reward is sent to the miner's primary address ([[node].seed](#node-seed) ).<br>If set to some principal address *and* the current Stacks epoch is > 2.1,<br>the reward will be directed to the specified address instead. | `None` |
| [<span id="miner-candidate_retry_cache_size">candidate_retry_cache_size</span>](#miner-candidate_retry_cache_size) | Max size (in *number* of items) of transaction candidates to hold in the in-memory<br>retry cache.<br><br>This cache stores transactions encountered during a `GlobalFeeRate` mempool walk<br>whose nonces are currently too high for immediate processing. These candidates<br>are prioritized for reconsideration later within the *same* walk, potentially<br>becoming valid if other processed transactions update the expected nonces.<br><br>A larger cache retains more potentially valid future candidates but uses more memory.<br>This setting is primarily relevant for the `GlobalFeeRate` strategy.<br><br>**Notes:**<br>- Each element `crate::core::mempool::MemPoolTxInfoPartial` is currently 112 bytes.<br><br>**Units:** items | `1048576` |
| [<span id="miner-empty_mempool_sleep_time">empty_mempool_sleep_time</span>](#miner-empty_mempool_sleep_time) | The amount of time in milliseconds that the miner should sleep in between attempts to<br>mine a block when the mempool is empty.<br><br>This prevents the miner from busy-looping when there are no pending transactions,<br>conserving CPU resources. During this sleep, the miner still checks burnchain tip changes.<br><br>**Units:** milliseconds | `2_500` |
| [<span id="miner-filter_origins">filter_origins</span>](#miner-filter_origins) | A comma separated list of Stacks addresses to whitelist so that only transactions from<br>these addresses should be considered during the mempool walk for block building. If this<br>list is non-empty, any transaction whose origin address is *not* in this set will be skipped.<br><br>This allows miners to prioritize transactions originating from specific accounts that are<br>important to them.<br>Configured as a comma-separated string of standard Stacks addresses (e.g., "ST123...,ST456...")<br>in the configuration file.<br><br>**Example:**<br><pre><code>filter_origins = "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2,ST319CF5WV77KYR1H3GT0GZ7B8Q4AQPY42ETP1VPF"</code></pre> | Empty set (all origins are considered). |
| [<span id="miner-first_rejection_pause_ms">first_rejection_pause_ms</span>](#miner-first_rejection_pause_ms) | Time in milliseconds to pause after receiving the first threshold rejection, before proposing a new block.<br><br>When a miner's block proposal fails to gather enough signatures from the signers for the first time<br>at a given height, the miner will pause for this duration before attempting to mine and propose again.<br><br>**Units:** milliseconds | `5_000` |
| [<span id="miner-max_execution_time_secs">max_execution_time_secs</span>](#miner-max_execution_time_secs) | Defines the maximum execution time (in seconds) allowed for a single contract call transaction.<br><br>When processing a transaction (contract call or smart contract deployment), if this option is set,<br>and the execution time exceeds this limit, the transaction processing fails with an `ExecutionTimeout` error,<br>and the transaction is skipped. This prevents potentially long-running or infinite-loop transactions<br>from blocking block production.<br><br>**Units:** seconds | `None` (no execution time limit) |
| [<span id="miner-mempool_walk_strategy">mempool_walk_strategy</span>](#miner-mempool_walk_strategy) | Strategy for selecting the next transaction candidate from the mempool.<br>Controls prioritization between maximizing immediate fee capture vs. ensuring<br>transaction nonce order for account progression and processing efficiency.<br><br>See `MemPoolWalkStrategy` for variant details.<br><br>Possible values (use variant names for configuration):<br>- `"GlobalFeeRate"`: Selects the transaction with the highest fee rate globally.<br>- `"NextNonceWithHighestFeeRate"`: Selects the highest-fee transaction among those<br>  matching the next expected nonce for sender/sponsor accounts. | `"GlobalFeeRate"` |
| [<span id="miner-min_time_between_blocks_ms">min_time_between_blocks_ms</span>](#miner-min_time_between_blocks_ms) | The minimum time to wait between mining blocks in milliseconds. The value must be greater<br>than or equal to 1000 ms because if a block is mined within the same second as its parent,<br>it will be rejected by the signers.<br><br>This check ensures compliance with signer rules that prevent blocks with identical timestamps<br>(at second resolution) to their parents. If a lower value is configured, 1000 ms is used instead.<br><br>**Units:** milliseconds | `1_000` |
| [<span id="miner-mining_key">mining_key</span>](#miner-mining_key) | The private key (Secp256k1) used for signing blocks, provided as a hex string.<br><br>This key must be present at runtime for mining operations to succeed. | - [[node].seed](#node-seed)  if the `[miner]` section *is present* in the config file<br>- `None` if the `[miner]` section *is not present* |
| [<span id="miner-nakamoto_attempt_time_ms">nakamoto_attempt_time_ms</span>](#miner-nakamoto_attempt_time_ms) | Maximum time (in milliseconds) the miner spends selecting transactions from the mempool<br>when assembling a Nakamoto block. Once this duration is exceeded, the miner stops<br>adding transactions and finalizes the block with those already selected.<br><br>**Units:** milliseconds | `5_000` (5 seconds) |
| [<span id="miner-nonce_cache_size">nonce_cache_size</span>](#miner-nonce_cache_size) | Max size (in bytes) of the in-memory cache for storing expected account nonces.<br><br>This cache accelerates mempool processing (e.g., during block building) by storing<br>the anticipated next nonce for accounts, reducing expensive lookups into the node's<br>state (MARF trie). A larger cache can improve performance for workloads involving<br>many unique accounts but increases memory consumption.<br><br>**Notes:**<br>- Must be configured to a value greater than 0.<br><br>**Units:** bytes | `1048576` (1 MiB) |
| [<span id="miner-probability_pick_no_estimate_tx">probability_pick_no_estimate_tx</span>](#miner-probability_pick_no_estimate_tx) | Probability (percentage, 0-100) of prioritizing a transaction without a known fee rate<br>during candidate selection.<br><br>Only effective when `mempool_walk_strategy` is `GlobalFeeRate`. Helps ensure<br>transactions lacking fee estimates are periodically considered alongside high-fee ones,<br>preventing potential starvation. A value of 0 means never prioritize them first,<br>100 means always prioritize them first (if available).<br><br>**Notes:**<br>- Values: 0-100.<br><br>**Units:** percent | `25` (25% chance) |
| [<span id="miner-replay_transactions">replay_transactions</span>](#miner-replay_transactions) | TODO: remove this option when its no longer a testing feature and it becomes default behaviour<br>The miner will attempt to replay transactions that a threshold number of signers are expecting in the next block | **Required** |
| [<span id="miner-segwit">segwit</span>](#miner-segwit) | If possible, mine with a p2wpkh address. | `false` |
| [<span id="miner-subsequent_rejection_pause_ms">subsequent_rejection_pause_ms</span>](#miner-subsequent_rejection_pause_ms) | Time in milliseconds to pause after receiving subsequent threshold rejections, before proposing a new block.<br><br>If a miner's block proposal is rejected multiple times at the same height (after the first rejection),<br>this potentially longer pause duration is used before retrying. This gives more significant time<br>for network state changes or signer coordination.<br><br>**Units:** milliseconds | `10_000` |
| [<span id="miner-tenure_cost_limit_per_block_percentage">tenure_cost_limit_per_block_percentage</span>](#miner-tenure_cost_limit_per_block_percentage) | The percentage of the remaining tenure cost limit to consume each block.<br><br>This setting limits the execution cost (Clarity cost) a single Nakamoto block can incur,<br>expressed as a percentage of the *remaining* cost budget for the current mining tenure.<br>For example, if set to 25, a block can use at most 25% of the tenure's currently available cost limit.<br>This allows miners to spread the tenure's total execution budget across multiple blocks rather than<br>potentially consuming it all in the first block.<br><br>**Notes:**<br>- Values: 1-100.<br>- Setting to 100 effectively disables this per-block limit, allowing a block to use the entire remaining tenure budget.<br><br>**Units:** percent | `25` |
| [<span id="miner-tenure_extend_cost_threshold">tenure_extend_cost_threshold</span>](#miner-tenure_extend_cost_threshold) | Percentage of block budget that must be used before attempting a time-based tenure extend.<br><br>This sets a minimum threshold for the accumulated execution cost within a tenure before a<br>time-based tenure extension ([tenure_timeout](#miner-tenure_timeout) ) can be initiated.<br>The miner checks if the proportion of the total tenure budget consumed so far exceeds this percentage.<br>If the cost usage is below this threshold, a time-based extension will not be attempted, even if<br>the [tenure_timeout](#miner-tenure_timeout)  duration has elapsed.<br>This prevents miners from extending tenures very early if they have produced only low-cost blocks.<br><br>**Notes:**<br>- Values: 0-100.<br><br>**Units:** percent | `50` |
| [<span id="miner-tenure_extend_poll_timeout">tenure_extend_poll_timeout</span>](#miner-tenure_extend_poll_timeout) | Duration to wait in-between polling the sortition DB to see if we need to<br>extend the ongoing tenure (e.g. because the current sortition is empty or invalid).<br><br>After the relayer determines that a tenure extension might be needed but cannot proceed immediately<br>(e.g., because a miner thread is already active for the current burn view), it will wait for this<br>duration before re-checking the conditions for tenure extension.<br><br>**Units:** seconds | `1` |
| [<span id="miner-tenure_extend_wait_timeout">tenure_extend_wait_timeout</span>](#miner-tenure_extend_wait_timeout) | Duration to wait before trying to continue a tenure because the next miner did not produce blocks.<br><br>If the node was the winner of the previous sortition but not the most recent one,<br>the relayer waits for this duration before attempting to extend its own tenure.<br>This gives the new winner of the most recent sortition a grace period to produce their first block.<br>Also used in scenarios with empty sortitions to give the winner of the *last valid* sortition time<br>to produce a block before the current miner attempts an extension.<br><br>**Units:** milliseconds | `120_000` |
| [<span id="miner-tenure_timeout">tenure_timeout</span>](#miner-tenure_timeout) | Duration to wait before attempting to issue a time-based tenure extend.<br><br>A miner can proactively attempt to extend its tenure if a significant amount of time has passed<br>since the last tenure change, even without an explicit trigger like an empty sortition.<br>If the time elapsed since the last tenure change exceeds this value, and the signer coordinator<br>indicates an extension is timely, and the cost usage threshold ([tenure_extend_cost_threshold](#miner-tenure_extend_cost_threshold) )<br>is met, the miner will include a tenure extension transaction in its next block.<br><br>**Units:** seconds | `180` |
| [<span id="miner-txs_to_consider">txs_to_consider</span>](#miner-txs_to_consider) | Specifies which types of transactions the miner should consider including in a block<br>during the mempool walk process. Transactions of types not included in this set will be skipped.<br><br>This allows miners to exclude specific transaction categories.<br>Configured as a comma-separated string of transaction type names in the configuration file.<br><br>Accepted values correspond to variants of `MemPoolWalkTxTypes`:<br>- `"TokenTransfer"`<br>- `"SmartContract"`<br>- `"ContractCall"`<br><br>**Example:**<br><pre><code>txs_to_consider = "TokenTransfer,ContractCall"</code></pre> | All transaction types are considered (equivalent to [`MemPoolWalkTxTypes::all()`]). |
| [<span id="miner-wait_for_block_download">wait_for_block_download</span>](#miner-wait_for_block_download) | Wait for a downloader pass before mining.<br>This can only be disabled in testing; it can't be changed in the config file. | `true` |
| ~~[<span id="miner-fast_rampup">fast_rampup</span>](#miner-fast_rampup)~~ | Controls how the miner estimates its win probability when checking for underperformance.<br><br>This estimation is used in conjunction with [target_win_probability](#miner-target_win_probability)  and<br>[underperform_stop_threshold](#miner-underperform_stop_threshold)  to decide whether to pause mining due to<br>low predicted success rate.<br><br>- If `true`: The win probability estimation looks at projected spend distributions<br>  ~6 blocks into the future. This might help the miner adjust its spending more quickly<br>  based on anticipated competition changes.<br>- If `false`: The win probability estimation uses the currently observed spend distribution<br>  for the next block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode and by the<br>`get-spend-amount` cli subcommand. | `false` |
| ~~[<span id="miner-first_attempt_time_ms">first_attempt_time_ms</span>](#miner-first_attempt_time_ms)~~ | Time to wait (in milliseconds) before the first attempt to mine a block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** milliseconds | `10` |
| ~~[<span id="miner-max_reorg_depth">max_reorg_depth</span>](#miner-max_reorg_depth)~~ | Defines the maximum depth (in Stacks blocks) the miner considers when evaluating<br>potential chain tips when selecting the best tip to mine the next block on.<br><br>The miner analyzes candidate tips within this depth from the highest known tip.<br>It selects the "nicest" tip, often defined as the one that minimizes chain reorganizations<br>or orphans within this lookback window. A lower value restricts the analysis to shallower forks,<br>while a higher value considers deeper potential reorganizations.<br><br>This setting influences which fork the miner chooses to build upon if multiple valid tips exist.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode and the<br>`pick-best-tip` cli subcommand. | `3` |
| ~~[<span id="miner-microblock_attempt_time_ms">microblock_attempt_time_ms</span>](#miner-microblock_attempt_time_ms)~~ | Time to wait (in milliseconds) to mine a microblock.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |
| ~~[<span id="miner-min_tx_count">min_tx_count</span>](#miner-min_tx_count)~~ | Minimum number of transactions that must be in a block if we're going to replace a pending<br>block-commit with a new block-commit.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `0` |
| ~~[<span id="miner-only_increase_tx_count">only_increase_tx_count</span>](#miner-only_increase_tx_count)~~ | If true, requires subsequent mining attempts for the same block height<br>to have a transaction count >= the previous best attempt.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `false` |
| ~~[<span id="miner-pre_nakamoto_mock_signing">pre_nakamoto_mock_signing</span>](#miner-pre_nakamoto_mock_signing)~~ | Enables a mock signing process for testing purposes, specifically designed for use during Epoch 2.5<br>before the activation of Nakamoto consensus.<br><br>When set to `true` and [mining_key](#miner-mining_key)  is provided, the miner will interact<br>with the `.miners` and `.signers` contracts via the stackerdb to send and receive mock<br>proposals and signatures, simulating aspects of the Nakamoto leader election and block signing flow.<br><br>**Notes:**<br>- This is intended strictly for testing purposes for Epoch 2.5 conditions.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. | `false` (Should only default true if [mining_key](#miner-mining_key)  is set). |
| ~~[<span id="miner-subsequent_attempt_time_ms">subsequent_attempt_time_ms</span>](#miner-subsequent_attempt_time_ms)~~ | Time to wait (in milliseconds) for subsequent attempts to mine a block,<br>after the first attempt fails.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** milliseconds | `120_000` (2 minutes) |
| ~~[<span id="miner-target_win_probability">target_win_probability</span>](#miner-target_win_probability)~~ | The minimum win probability this miner aims to achieve in block sortitions.<br><br>This target is used to detect prolonged periods of underperformance. If the miner's<br>calculated win probability consistently falls below this value for a duration specified<br>by [underperform_stop_threshold](#miner-underperform_stop_threshold)  (after an initial startup phase), the miner may<br>cease spending in subsequent sortitions (returning a burn fee cap of 0) to conserve resources.<br><br>Setting this value close to 0.0 effectively disables the underperformance check.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `0.0` |
| ~~[<span id="miner-unconfirmed_commits_helper">unconfirmed_commits_helper</span>](#miner-unconfirmed_commits_helper)~~ | Optional path to an external helper script for fetching unconfirmed block-commits.<br>Used to inform the miner's dynamic burn fee bidding strategy with off-chain data.<br><br>If a path is provided, the target script must:<br>- Be executable by the user running the Stacks node process.<br>- Accept a list of active miner burnchain addresses as command-line arguments.<br>- On successful execution, print a JSON array representing `Vec<UnconfirmedBlockCommit>`<br>  (see `stacks::config::chain_data::UnconfirmedBlockCommit` struct) to stdout.<br>- Exit with code 0 on success.<br><br>Look at `test_get_unconfirmed_commits` in `stackslib/src/config/chain_data.rs` for an example script.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode and by the<br>`get-spend-amount` cli subcommand. | `None` (feature disabled). |
| ~~[<span id="miner-underperform_stop_threshold">underperform_stop_threshold</span>](#miner-underperform_stop_threshold)~~ | The maximum number of consecutive Bitcoin blocks the miner will tolerate underperforming<br>(i.e., having a calculated win probability below [target_win_probability](#miner-target_win_probability) )<br>before temporarily pausing mining efforts.<br><br>This check is only active after an initial startup phase (6 blocks past the mining start height).<br>If the miner underperforms for this number of consecutive blocks, the<br>`BlockMinerThread::get_mining_spend_amount` function will return 0, effectively preventing the<br>miner from submitting a block commit for the current sortition to conserve funds.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `None` (underperformance check is disabled). |
| ~~[<span id="miner-unprocessed_block_deadline_secs">unprocessed_block_deadline_secs</span>](#miner-unprocessed_block_deadline_secs)~~ | Amount of time (in seconds) to wait for unprocessed blocks before mining a new block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** seconds | `30` |
| ~~[<span id="miner-wait_on_interim_blocks">wait_on_interim_blocks</span>](#miner-wait_on_interim_blocks)~~ | Amount of time while mining in nakamoto to wait in between mining interim blocks.<br><br>**⚠️ DEPRECATED:** Use `min_time_between_blocks_ms` instead. | `None` |


