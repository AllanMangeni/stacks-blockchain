# Stacks Node Configuration Reference

This document provides a comprehensive reference for all configuration options available in the Stacks node TOML configuration file.

The configuration is automatically generated from the Rust source code documentation.

## Table of Contents

- [[[ustx_balance]]](#ustx_balance)
- [[[events_observer]]](#events_observer)
- [[connection_options]](#connection_options)
- [[fee_estimation]](#fee_estimation)
- [[burnchain]](#burnchain)
- [[node]](#node)
- [[miner]](#miner)


## [[ustx_balance]]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="ustx_balance-address">address</span>](#ustx_balance-address) | The Stacks address to receive the initial STX balance.<br>Must be a valid "non-mainnet" Stacks address (e.g., "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2"). | **Required** |
| [<span id="ustx_balance-amount">amount</span>](#ustx_balance-amount) | The amount of microSTX to allocate to the address at node startup.<br>1 STX = 1,000,000 microSTX.<br><br>**Units:** microSTX | **Required** |


## [[events_observer]]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="events_observer-disable_retries">disable_retries</span>](#events_observer-disable_retries) | Controls whether the node should retry sending event notifications if delivery<br>fails or times out.<br><br>If `false` (default): The node will attempt to deliver event notifications<br>  persistently. If an attempt fails (due to network error, timeout, or a<br>  non-200 HTTP response), the event payload is saved and retried indefinitely.<br>  This ensures that all events will eventually be delivered. However, this can<br>  cause the node's block processing to stall if an observer is down, or<br>  indefinitely fails to process the event.<br><br>- If `true`: The node will make only a single attempt to deliver each event<br>  notification. If this single attempt fails for any reason, the event is<br>  discarded, and no further retries will be made for that specific event.<br><br>**Notes:**<br>- **Warning:** Setting this to `true` can lead to missed events if the observer endpoint is temporarily unavailable or experiences issues. | `false` (retries are enabled) |
| [<span id="events_observer-endpoint">endpoint</span>](#events_observer-endpoint) | URL endpoint (hostname and port) where event notifications will be sent via<br>HTTP POST requests.<br><br>The node will automatically prepend `http://` to this endpoint and append the<br>specific event path (e.g., `/new_block`, `/new_mempool_tx`). Therefore, this<br>value should be specified as `hostname:port` (e.g., "localhost:3700").<br><br>This should point to a service capable of receiving and processing Stacks event data.<br><br>**Notes:**<br>- **Do NOT include the `http://` scheme in this configuration value.**<br><br>**Example:**<br><pre><code>endpoint = "localhost:3700"</code></pre> | **Required** |
| [<span id="events_observer-events_keys">events_keys</span>](#events_observer-events_keys) | List of event types that this observer is configured to receive.<br><br>Each string in the list specifies an event category or a specific event to<br>subscribe to. For an observer to receive any notifications, this list must<br>contain at least one valid key. Providing an invalid string that doesn't match<br>any of the valid formats below will cause the node to panic on startup when<br>parsing the configuration.<br><br>All observers, regardless of their `events_keys` configuration, implicitly<br>receive payloads on the `/attachments/new` endpoint.<br><br>Valid Event Keys:<br>- `"*"`: Subscribes to a broad set of common events.<br>&nbsp;&nbsp;- Events delivered to:<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_block`: For blocks containing transactions that generate STX, FT,<br>      NFT, or smart contract events.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_microblocks`: For all new microblock streams. Note: Only until epoch 2.5.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_mempool_tx`: For new mempool transactions.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/drop_mempool_tx`: For dropped mempool transactions.<br>&nbsp;&nbsp;&nbsp;&nbsp;- `/new_burn_block`: For new burnchain blocks.<br>&nbsp;&nbsp;- Note: This key does NOT by itself subscribe to `/stackerdb_chunks` or `/proposal_response`.<br><br>- `"stx"`: Subscribes to STX token operation events (transfer, mint, burn, lock).<br>&nbsp;&nbsp;- Events delivered to: `/new_block`, `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details: The "events" array in the delivered payloads will be<br>    filtered to include only STX-related events.<br><br>- `"memtx"`: Subscribes to new and dropped mempool transaction events.<br>&nbsp;&nbsp;- Events delivered to: `/new_mempool_tx`, `/drop_mempool_tx`.<br><br>- `"burn_blocks"`: Subscribes to new burnchain block events.<br>&nbsp;&nbsp;- Events delivered to: `/new_burn_block`.<br><br>- `"microblocks"`: Subscribes to new microblock stream events.<br>&nbsp;&nbsp;- Events delivered to: `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details:<br>&nbsp;&nbsp;&nbsp;&nbsp;- The "transactions" field will contain all transactions from the microblocks.<br>&nbsp;&nbsp;&nbsp;&nbsp;- The "events" field will contain STX, FT, NFT, or specific smart contract<br>      events *only if* this observer is also subscribed to those more specific<br>      event types (e.g., via `"stx"`, `"*"`, a specific contract event key,<br>      or a specific asset identifier key).<br>&nbsp;&nbsp;- Note: Only until epoch 2.5.<br><br>- `"stackerdb"`: Subscribes to StackerDB chunk update events.<br>&nbsp;&nbsp;- Events delivered to: `/stackerdb_chunks`.<br><br>- `"block_proposal"`: Subscribes to block proposal response events (for Nakamoto consensus).<br>&nbsp;&nbsp;- Events delivered to: `/proposal_response`.<br><br>- Smart Contract Event: Subscribes to a specific smart contract event.<br>&nbsp;&nbsp;- Format: `"{contract_address}.{contract_name}::{event_name}"`<br>    (e.g., `ST0000000000000000000000000000000000000000.my-contract::my-custom-event`)<br>&nbsp;&nbsp;- Events delivered to: `/new_block`, `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details: The "events" array in the delivered payloads will be<br>    filtered for this specific event.<br><br>- Asset Identifier for FT/NFT Events: Subscribes to events (mint, burn,<br>  transfer) for a specific Fungible Token (FT) or Non-Fungible Token (NFT).<br>&nbsp;&nbsp;- Format: `"{contract_address}.{contract_name}.{asset_name}"`<br>    (e.g., for an FT: `ST0000000000000000000000000000000000000000.contract.token`)<br>&nbsp;&nbsp;- Events delivered to: `/new_block`, `/new_microblocks`.<br>&nbsp;&nbsp;- Payload details: The "events" array in the delivered payloads will be<br>    filtered for events related to the specified asset.<br><br>**Notes:**<br>- For a more detailed documentation check the event-dispatcher docs in the `/docs` folder.<br><br>**Example:**<br><pre><code>events_keys = [&#10;  "burn_blocks",&#10;  "memtx",&#10;  "ST0000000000000000000000000000000000000000.my-contract::my-custom-event",&#10;  "ST0000000000000000000000000000000000000000.token-contract.my-ft"&#10;]</code></pre> | **Required** |
| [<span id="events_observer-timeout_ms">timeout_ms</span>](#events_observer-timeout_ms) | Maximum duration (in milliseconds) to wait for the observer endpoint to respond.<br><br>When the node sends an event notification to this observer, it will wait at<br>most this long for a successful HTTP response (status code 200) before<br>considering the request timed out. If a timeout occurs and retries are enabled<br>(see [disable_retries](#events_observer-disable_retries) ), the request will be attempted<br>again according to the retry strategy.<br><br>**Units:** milliseconds | `1_000` |


## [connection_options]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="connection_options-auth_token">auth_token</span>](#connection_options-auth_token) | HTTP auth password to use when communicating with stacks-signer binary.<br><br>This token is used in the `Authorization` header for certain requests.<br>Primarily, it secures the communication channel between this node and a<br>connected `stacks-signer` instance.<br><br>It is also used to authenticate requests to `/v2/blocks?broadcast=1`.<br><br>**Notes:**<br>- This field **must** be configured if the node needs to receive block proposals from a configured `stacks-signer` [[events_observer]] via the `/v3/block_proposal` endpoint.<br>- The value must match the token configured on the signer. | `None` (authentication disabled for relevant endpoints) |
| [<span id="connection_options-block_proposal_max_age_secs">block_proposal_max_age_secs</span>](#connection_options-block_proposal_max_age_secs) | Maximum age (in seconds) allowed for a block proposal received via the<br>`/v3/block_proposal` RPC endpoint.<br><br>If a block proposal is received whose timestamp is older than the current<br>time minus this configured value, the node will reject the proposal with an<br>HTTP 422 (Unprocessable Entity) error, considering it too stale. This<br>prevents the node from spending resources validating outdated proposals.<br><br>**Units:** seconds | `600` |
| [<span id="connection_options-connect_timeout">connect_timeout</span>](#connection_options-connect_timeout) | Maximum duration (in seconds) a connection attempt is allowed to remain in<br>the connecting state.<br><br>This applies to both incoming P2P and HTTP connections. If a remote peer<br>initiates a connection but does not complete the connection process<br>(e.g., handshake for P2P) within this time, the node will consider it<br>unresponsive and drop the connection attempt.<br><br>**Units:** seconds | `10` |
| [<span id="connection_options-disable_block_download">disable_block_download</span>](#connection_options-disable_block_download) | If true, completely disables the block download state machine.<br><br>The node will not attempt to download Stacks blocks (neither Nakamoto<br>tenures nor legacy blocks) from peers.<br><br>**Notes:**<br>- Intended for testing or specialized node configurations. | `false` |
| [<span id="connection_options-disable_inbound_handshakes">disable_inbound_handshakes</span>](#connection_options-disable_inbound_handshakes) | If true, prevents the node from processing initial handshake messages from new<br>inbound P2P connections.<br><br>This effectively stops the node from establishing new authenticated inbound<br>P2P sessions. Outbound connections initiated by this node are unaffected.<br><br>**Notes:**<br>- Primarily intended for testing purposes. | `false` |
| [<span id="connection_options-disable_inbound_walks">disable_inbound_walks</span>](#connection_options-disable_inbound_walks) | If true, disables the neighbor discovery mechanism from starting walks from<br>inbound peers. Walks will only initiate from seed/bootstrap peers, outbound<br>connections, or pingbacks.<br><br>**Notes:**<br>- Primarily intended for testing or specific network debugging scenarios. | `false` |
| [<span id="connection_options-dns_timeout">dns_timeout</span>](#connection_options-dns_timeout) | Maximum time (in milliseconds) to wait for a DNS query to resolve.<br><br>When the node needs to resolve a hostname (e.g., from a peer's advertised<br>[[node].data_url](#node-data_url)  or an Atlas attachment URL) into an IP address, it<br>initiates a DNS lookup. This setting defines the maximum duration the node will<br>wait for the DNS server to respond before considering the lookup timed out.<br><br>**Units:** milliseconds | `15_000` (15 seconds) |
| [<span id="connection_options-force_disconnect_interval">force_disconnect_interval</span>](#connection_options-force_disconnect_interval) | Fault injection setting for testing purposes. Interval (in seconds) for<br>forced disconnection of all peers.<br><br>If set to a positive value, the node will periodically disconnect all of its<br>P2P peers at roughly this interval. This simulates network churn or<br>partitioning for testing node resilience.<br><br>**Notes:**<br>- If set to a positive value, the node will periodically disconnect all of its P2P peers at roughly this interval.<br>- This simulates network churn or partitioning for testing node resilience.<br>- The code enforcing this behavior is conditionally compiled using `cfg!(test)` and is only active during test runs.<br>- This setting has no effect in standard production builds.<br><br>**Units:** seconds | `None` (feature disabled) |
| [<span id="connection_options-handshake_timeout">handshake_timeout</span>](#connection_options-handshake_timeout) | Maximum duration (in seconds) a P2P peer is allowed after connecting before<br>completing the handshake.<br><br>If a P2P peer connects successfully but fails to send the necessary handshake<br>messages within this time, the node will consider it unresponsive and drop the<br>connection.<br><br>**Units:** seconds | `5` |
| [<span id="connection_options-heartbeat">heartbeat</span>](#connection_options-heartbeat) | Interval (in seconds) at which this node expects to send or receive P2P<br>keep-alive messages.<br><br>During the P2P handshake, this node advertises this configured `heartbeat`<br>value to its peers. Each peer uses the other's advertised heartbeat<br>interval (plus a timeout margin) to monitor responsiveness and detect<br>potential disconnections. This node also uses its own configured value to<br>proactively send Ping messages if the connection would otherwise be idle,<br>helping to keep it active.<br><br>**Units:** seconds | `3_600` (1 hour) |
| [<span id="connection_options-idle_timeout">idle_timeout</span>](#connection_options-idle_timeout) | Maximum idle time (in seconds) for HTTP connections.<br><br>This applies only to HTTP connections. It defines the maximum allowed time<br>since the last response was sent by the node to the client. An HTTP<br>connection is dropped if both this `idle_timeout` and the general<br>[timeout](#connection_options-timeout)  (time since last request received) are exceeded.<br><br>**Units:** seconds | `15` |
| [<span id="connection_options-inbox_maxlen">inbox_maxlen</span>](#connection_options-inbox_maxlen) | Maximum number of messages allowed in the per-connection incoming buffer.<br>The limits apply individually to each established connection (both P2P and HTTP). | `100` |
| [<span id="connection_options-inv_reward_cycles">inv_reward_cycles</span>](#connection_options-inv_reward_cycles) | Lookback depth (in PoX reward cycles) for Nakamoto inventory synchronization requests.<br><br>When initiating an inventory sync cycle with a peer, the node requests data<br>starting from `inv_reward_cycles` cycles before the current target reward<br>cycle. This determines how much historical inventory information is requested<br>in each sync attempt.<br><br>**Units:** PoX reward cycles | - if [[burnchain].mode](#burnchain-mode)  is `"mainnet"`: `3`<br>- else: `6` |
| [<span id="connection_options-inv_sync_interval">inv_sync_interval</span>](#connection_options-inv_sync_interval) | Minimum interval (in seconds) between initiating inventory synchronization<br>attempts with the same peer.<br><br>Acts as a per-peer cooldown to throttle sync requests. A new sync cycle with<br>a peer generally starts only after this interval has passed since the previous<br>attempt began *and* the previous cycle is considered complete.<br><br>**Units:** seconds | `45` |
| [<span id="connection_options-log_neighbors_freq">log_neighbors_freq</span>](#connection_options-log_neighbors_freq) | Frequency (in milliseconds) for logging the current P2P neighbor list at the<br>DEBUG level.<br><br>If set to a non-zero value, the node will periodically log details about its<br>currently established P2P connections (neighbors). Setting this to 0 disables<br>this periodic logging.<br><br>**Units:** milliseconds | `60_000` (1 minute) |
| [<span id="connection_options-max_http_clients">max_http_clients</span>](#connection_options-max_http_clients) | Maximum total number of allowed concurrent HTTP connections.<br><br>This limits the total number of simultaneous connections the node's RPC/HTTP<br>server will accept. If this limit is reached, new incoming HTTP connection<br>attempts will be rejected. | `1000` |
| [<span id="connection_options-max_inflight_attachments">max_inflight_attachments</span>](#connection_options-max_inflight_attachments) | Maximum number of concurrent Atlas data attachment download requests allowed.<br><br>This limits how many separate download requests for Atlas data attachments<br>can be active simultaneously. Helps manage network resources when fetching<br>potentially large attachment data. | `6` |
| [<span id="connection_options-max_inflight_blocks">max_inflight_blocks</span>](#connection_options-max_inflight_blocks) | Maximum number of concurrent Nakamoto block download requests allowed.<br><br>This limits how many separate block download processes for Nakamoto tenures<br>(both confirmed and unconfirmed) can be active simultaneously. Helps manage<br>network bandwidth and processing load during chain synchronization. | `6` |
| [<span id="connection_options-max_sockets">max_sockets</span>](#connection_options-max_sockets) | Maximum total number of concurrent network sockets the node is allowed to manage.<br><br>This limit applies globally to all types of sockets handled by the node's<br>networking layer, including listening sockets (P2P and RPC/HTTP),<br>established P2P connections (inbound/outbound), and established HTTP connections.<br>It serves as a hard limit to prevent the node from exhausting operating<br>system resources related to socket descriptors. | `800` |
| [<span id="connection_options-maximum_call_argument_size">maximum_call_argument_size</span>](#connection_options-maximum_call_argument_size) | Maximum size (in bytes) of the HTTP request body for read-only contract calls.<br><br>This limit is enforced on the `Content-Length` of incoming requests to the<br>`/v2/contracts/call-read-only/...` RPC endpoint. It prevents excessively large<br>request bodies, which might contain numerous or very large hex-encoded<br>function arguments, from overwhelming the node.<br><br>**Notes:**<br>- Calculated as 20 * `clarity::vm::types::BOUND_VALUE_SERIALIZATION_HEX`.<br><br>**Units:** bytes | `83_886_080` (80 MiB) |
| [<span id="connection_options-num_clients">num_clients</span>](#connection_options-num_clients) | Maximum number of allowed concurrent inbound P2P connections.<br><br>This acts as a hard limit. If the node already has this many active inbound<br>P2P connections, any new incoming P2P connection attempts will be rejected.<br>Outbound P2P connections initiated by this node are not counted against this limit. | `750` |
| [<span id="connection_options-num_neighbors">num_neighbors</span>](#connection_options-num_neighbors) | Target number of peers for StackerDB replication.<br><br>Sets the maximum number of potential replication target peers requested from<br>the StackerDB control contract (`get-replication-targets`) when configuring a replica.<br><br>Note: Formerly (pre-Epoch 3.0), this also controlled the target peer count for<br>inventory synchronization. | `32` |
| [<span id="connection_options-outbox_maxlen">outbox_maxlen</span>](#connection_options-outbox_maxlen) | Maximum number of messages allowed in the per-connection outgoing buffer.<br>The limit applies individually to each established connection (both P2P and HTTP). | `100` |
| [<span id="connection_options-private_key_lifetime">private_key_lifetime</span>](#connection_options-private_key_lifetime) | Validity duration (in number of bitcoin blocks) for the node's P2P session<br>private key.<br><br>The node uses a temporary private key for signing P2P messages. This key has<br>an associated expiry bitcoin block height stored in the peer database. When<br>the current bitcoin height reaches or exceeds the key's expiry height, the<br>node automatically generates a new random private key.<br>The expiry block height for this new key is calculated by adding the<br>configured [private_key_lifetime](#connection_options-private_key_lifetime)  (in blocks) to the<br>previous key's expiry block height. The node then re-handshakes with peers<br>to transition to the new key. This provides periodic key rotation for P2P communication.<br><br>**Units:** bitcoin blocks | `9223372036854775807` (i64::MAX, effectively infinite, disabling automatic re-keying). |
| [<span id="connection_options-private_neighbors">private_neighbors</span>](#connection_options-private_neighbors) | Whether to allow connections and interactions with peers having private IP addresses.<br><br>If `false` (default), the node will generally:<br>- Reject incoming connection attempts from peers with private IPs.<br>- Avoid initiating connections to peers known to have private IPs.<br>- Ignore peers with private IPs during neighbor discovery (walks).<br>- Skip querying peers with private IPs for mempool or StackerDB data.<br>- Filter out peers with private IPs from API responses listing potential peers.<br><br>Setting this to `true` disables these restrictions, which can be useful for<br>local testing environments or fully private network deployments. | `false` |
| [<span id="connection_options-public_ip_address">public_ip_address</span>](#connection_options-public_ip_address) | The Public IPv4 address and port (e.g. "203.0.113.42:20444") to advertise to other nodes.<br><br>If this option is not set (`None`), the node will attempt to automatically<br>discover its public IP address. | `None` (triggers automatic discovery attempt) |
| [<span id="connection_options-read_only_call_limit_read_count">read_only_call_limit_read_count</span>](#connection_options-read_only_call_limit_read_count) | Maximum number of distinct read operations from Clarity data space allowed<br>during a read-only call. | `30` |
| [<span id="connection_options-read_only_call_limit_read_length">read_only_call_limit_read_length</span>](#connection_options-read_only_call_limit_read_length) | Maximum total size (in bytes) of data allowed to be read from Clarity data<br>space (variables, maps) during a read-only call.<br><br>**Units:** bytes | `100_000` (100 KB). |
| [<span id="connection_options-read_only_call_limit_runtime">read_only_call_limit_runtime</span>](#connection_options-read_only_call_limit_runtime) | Runtime cost limit for an individual read-only function call. This represents<br>computation effort within the Clarity VM.<br>(See SIP-006: https://github.com/stacksgov/sips/blob/main/sips/sip-006/sip-006-runtime-cost-assessment.md)<br><br>**Units:** Clarity VM cost units | `1_000_000_000` |
| [<span id="connection_options-read_only_call_limit_write_count">read_only_call_limit_write_count</span>](#connection_options-read_only_call_limit_write_count) | Maximum number of distinct write operations allowed during a read-only call.<br><br>**Notes:**<br>- This limit is effectively forced to 0 by the API handler, ensuring read-only behavior.<br>- Configuring a non-zero value has no effect on read-only call execution. | `0` |
| [<span id="connection_options-read_only_call_limit_write_length">read_only_call_limit_write_length</span>](#connection_options-read_only_call_limit_write_length) | Maximum total size (in bytes) of data allowed to be written during a read-only call.<br><br>**Notes:**<br>- This limit is effectively forced to 0 by the API handler, ensuring read-only behavior.<br>- Configuring a non-zero value has no effect on read-only call execution.<br><br>**Units:** bytes | `0` |
| [<span id="connection_options-reject_blocks_pushed">reject_blocks_pushed</span>](#connection_options-reject_blocks_pushed) | Controls whether the node accepts Nakamoto blocks pushed proactively by peers.<br><br>- If `true`: Pushed blocks are ignored (logged at DEBUG and discarded). The<br>  node will still process blocks that it actively downloads.<br>- If `false`: Both pushed blocks and actively downloaded blocks are processed. | `false` |
| [<span id="connection_options-soft_max_clients_per_host">soft_max_clients_per_host</span>](#connection_options-soft_max_clients_per_host) | Soft limit on the number of inbound P2P connections allowed per host IP address.<br><br>During inbound connection pruning (when total inbound connections ><br>[soft_num_clients](#connection_options-soft_num_clients) ), the node checks if any single<br>IP address has more connections than this limit. If so, it preferentially<br>prunes the newest connections originating from that specific IP address<br>until its count is reduced to this limit. This prevents a single host from<br>dominating the node's inbound connection capacity. | `4` |
| [<span id="connection_options-soft_max_neighbors_per_org">soft_max_neighbors_per_org</span>](#connection_options-soft_max_neighbors_per_org) | Soft limit on the number of outbound P2P connections per network organization (ASN).<br><br>During connection pruning (when total outbound connections ><br>[soft_num_neighbors](#connection_options-soft_num_neighbors) ), the node checks if any single<br>network organization (identified by ASN) has more outbound connections than<br>this limit. If so, it preferentially prunes the least healthy/newest<br>connections from that overrepresented organization until its count is<br>reduced to this limit or the total outbound count reaches<br>[soft_num_neighbors](#connection_options-soft_num_neighbors) . This encourages connection diversity<br>across different network providers. | `32` |
| [<span id="connection_options-soft_num_clients">soft_num_clients</span>](#connection_options-soft_num_clients) | Soft limit threshold for triggering inbound P2P connection pruning.<br><br>If the total number of currently active inbound P2P connections exceeds this<br>value, the node will activate pruning logic to reduce the count, typically by<br>applying per-host limits (see [soft_max_clients_per_host](#connection_options-soft_max_clients_per_host) ).<br>This helps manage the overall load from inbound peers. | `750` |
| [<span id="connection_options-soft_num_neighbors">soft_num_neighbors</span>](#connection_options-soft_num_neighbors) | Target number of outbound P2P connections the node aims to maintain.<br><br>The connection pruning logic only activates if the current number of established<br>outbound P2P connections exceeds this value. Pruning aims to reduce the<br>connection count back down to this target, ensuring the node maintains a<br>baseline number of outbound peers for network connectivity. | `16` |
| [<span id="connection_options-stackerdb_hint_replicas">stackerdb_hint_replicas</span>](#connection_options-stackerdb_hint_replicas) | Static list of preferred replica peers for specific StackerDB contracts,<br>provided as a JSON string.<br><br>This allows manually specifying known peers to use for replicating particular<br>StackerDBs, potentially overriding or supplementing the peers discovered via<br>the StackerDB's control contract.<br><br>Format: The configuration value must be a TOML string containing valid JSON.<br>The JSON structure must be an array of tuples, where each tuple pairs a<br>contract identifier with a list of preferred neighbor addresses:<br>`[[ContractIdentifier, [NeighborAddress, ...]], ...]`<br><br>1.  `ContractIdentifier`: A JSON object representing the `QualifiedContractIdentifier`.<br>    It must have the specific structure:<br>    `{"issuer": [version_byte, [byte_array_20]], "name": "contract-name"}`<br><br>2.  `NeighborAddress`: A JSON object specifying the peer details:<br>    `{"ip": "...", "port": ..., "public_key_hash": "..."}`<br><br>**Notes:**<br>- Use this option with caution, primarily for advanced testing or bootstrapping.<br><br>**Example:**<br><pre><code>stackerdb_hint_replicas = '''&#10;[&#10;  [&#10;    {&#10;      "issuer": [1, [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]],&#10;      "name": "my-contract"&#10;    },&#10;    [&#10;      {&#10;        "ip": "192.0.2.1",&#10;        "port": 20444,&#10;        "public_key_hash": "0102030405060708090a0b0c0d0e0f1011121314"&#10;      }&#10;    ]&#10;  ]&#10;]&#10;'''</code></pre> | `None` (no hints provided) |
| [<span id="connection_options-timeout">timeout</span>](#connection_options-timeout) | General communication timeout (in seconds).<br><br>- For HTTP connections: Governs two timeout aspects:<br>&nbsp;&nbsp;- Server-side: Defines the maximum allowed time since the last request was<br>    received from a client. An idle connection is dropped if both this<br>    timeout and [idle_timeout](#connection_options-idle_timeout)  are exceeded.<br>&nbsp;&nbsp;- Client-side: Sets the timeout duration (TTL) for outgoing HTTP requests<br>    initiated by the node itself.<br>- For P2P connections: Used as the specific timeout for NAT punch-through requests.<br><br>**Units:** seconds | `15` |
| [<span id="connection_options-walk_interval">walk_interval</span>](#connection_options-walk_interval) | Minimum interval (in seconds) between the start of consecutive neighbor discovery walks.<br><br>The node periodically performs "neighbor walks" to discover new peers and<br>maintain an up-to-date view of the P2P network topology. This setting<br>controls how frequently these walks can be initiated, preventing excessive<br>network traffic and processing.<br><br>**Units:** seconds | `60` |
| [<span id="connection_options-walk_seed_probability">walk_seed_probability</span>](#connection_options-walk_seed_probability) | Probability (0.0 to 1.0) of forcing a neighbor walk to start from a seed/bootstrap peer.<br><br>This probability applies only when the node is not in Initial Block Download (IBD)<br>and is already connected to at least one seed/bootstrap peer.<br>Normally, in this situation, the walk would start from a random inbound or<br>outbound peer. However, with this probability, the walk is forced to start<br>from a seed peer instead. This helps ensure the node periodically<br>re-establishes its network view from trusted entry points. | `0.1` (10%) |
| ~~[<span id="connection_options-antientropy_public">antientropy_public</span>](#connection_options-antientropy_public)~~ | Controls whether a node with public inbound connections should still push<br>blocks, even if not NAT'ed.<br><br>In the Stacks 2.x anti-entropy logic, if a node detected it had inbound<br>connections from public IPs (suggesting it wasn't behind NAT) and this flag<br>was set to `false`, it would refrain from proactively pushing blocks and<br>microblocks to peers. The assumption was that publicly reachable nodes should<br>primarily serve downloads. If set to `true` (default), the node would push<br>data regardless of its perceived reachability.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. | `true` |
| ~~[<span id="connection_options-antientropy_retry">antientropy_retry</span>](#connection_options-antientropy_retry)~~ | Minimum interval (in seconds) between attempts to run the Epoch 2.x anti-entropy<br>data push mechanism.<br><br>The Stacks 2.x anti-entropy protocol involves the node proactively pushing its<br>known Stacks blocks and microblocks to peers. This value specifies the<br>cooldown period for this operation. This prevents the node from excessively<br>attempting to push data to its peers.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+.<br><br>**Units:** seconds | `3_600` (1 hour) |
| ~~[<span id="connection_options-download_interval">download_interval</span>](#connection_options-download_interval)~~ | Minimum interval (in seconds) between consecutive block download scans in epoch 2.x.<br><br>In the pre-Nakamoto block download logic, if a full scan for blocks completed<br>without finding any new blocks to download, and if the known peer inventories<br>had not changed, the node would wait at least this duration before<br>initiating the next download scan. This throttled the downloader when the<br>node was likely already synchronized.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+.<br><br>**Units:** seconds | `10` |
| ~~[<span id="connection_options-full_inv_sync_interval">full_inv_sync_interval</span>](#connection_options-full_inv_sync_interval)~~ | Deprecated: it does not have any effect on the node's behavior.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `None` |
| ~~[<span id="connection_options-max_clients_per_host">max_clients_per_host</span>](#connection_options-max_clients_per_host)~~ | Maximum number of inbound p2p connections per host we permit.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `4` |
| ~~[<span id="connection_options-max_neighbors_per_host">max_neighbors_per_host</span>](#connection_options-max_neighbors_per_host)~~ | Maximum number of neighbors per host we permit.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `1` |
| ~~[<span id="connection_options-soft_max_neighbors_per_host">soft_max_neighbors_per_host</span>](#connection_options-soft_max_neighbors_per_host)~~ | Soft limit on the number of neighbors per host we permit.<br><br>**⚠️ DEPRECATED:** It does not have any effect on the node's behavior. | `1` |


## [fee_estimation]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="fee_estimation-cost_estimator">cost_estimator</span>](#fee_estimation-cost_estimator) | Specifies the name of the cost estimator to use.<br>This controls how the node estimates computational costs for transactions.<br><br>Accepted values:<br>- `"NaivePessimistic"`: The only currently supported cost estimator. This estimator<br>  tracks the highest observed costs for each operation type and uses the average<br>  of the top 10 values as its estimate, providing a conservative approach to<br>  cost estimation.<br><br>**Notes:**<br>- If [disabled](#fee_estimation-disabled)  is `true`, the node will use the default unit cost estimator. | `"NaivePessimistic"` |
| [<span id="fee_estimation-cost_metric">cost_metric</span>](#fee_estimation-cost_metric) | Specifies the name of the cost metric to use.<br>This controls how the node measures and compares transaction costs.<br><br>Accepted values:<br>- `"ProportionDotProduct"`: The only currently supported cost metric. This metric<br>  computes a weighted sum of cost dimensions (runtime, read/write counts, etc.)<br>  proportional to how much of the block limit they consume.<br><br>**Notes:**<br>- If [disabled](#fee_estimation-disabled)  is `true`, the node will use the default unit cost metric. | `"ProportionDotProduct"` |
| [<span id="fee_estimation-disabled">disabled</span>](#fee_estimation-disabled) | If `true`, all fee and cost estimation features are disabled.<br>The node will use unit estimators and metrics, which effectively provide no<br>actual estimation capabilities.<br><br>When disabled, the node will:<br>1. Not track historical transaction costs or fee rates.<br>2. Return simple unit values for costs for any transaction, regardless of<br>   its actual complexity.<br>3. Be unable to provide meaningful fee estimates for API requests (always<br>   returns an error).<br>4. Consider only raw transaction fees (not fees per cost unit) when<br>   assembling blocks.<br><br>This setting takes precedence over individual estimator/metric configurations.<br><br>**Notes:**<br>- When `true`, the values for [cost_estimator](#fee_estimation-cost_estimator) , [fee_estimator](#fee_estimation-fee_estimator) , and [cost_metric](#fee_estimation-cost_metric)  are ignored. | `false` |
| [<span id="fee_estimation-fee_estimator">fee_estimator</span>](#fee_estimation-fee_estimator) | Specifies the name of the fee estimator to use.<br>This controls how the node calculates appropriate transaction fees based on costs.<br><br>Accepted values:<br>- `"ScalarFeeRate"`: Simple multiplier-based fee estimation that uses percentiles<br>  (5th, 50th, and 95th) of observed fee rates from recent blocks.<br>- `"FuzzedWeightedMedianFeeRate"`: Fee estimation that adds controlled randomness<br>  to a weighted median rate calculator. This helps prevent fee optimization attacks<br>  by adding unpredictability to fee estimates while still maintaining accuracy.<br><br>**Notes:**<br>- If [disabled](#fee_estimation-disabled)  is `true`, the node will use the default unit fee estimator. | `"ScalarFeeRate"` |
| [<span id="fee_estimation-fee_rate_fuzzer_fraction">fee_rate_fuzzer_fraction</span>](#fee_estimation-fee_rate_fuzzer_fraction) | Specifies the fraction of random noise to add if using the<br>`FuzzedWeightedMedianFeeRate` fee estimator. This value should be in the<br>range [0, 1], representing a percentage of the base fee rate.<br><br>For example, with a value of 0.1 (10%), fee rate estimates will have random<br>noise added within the range of ±10% of the original estimate. This<br>randomization makes it difficult for users to precisely optimize their fees<br>while still providing reasonable estimates.<br><br>**Notes:**<br>- This setting is only relevant when [fee_estimator](#fee_estimation-fee_estimator)  is set to `"FuzzedWeightedMedianFeeRate"`. | `0.1` (10%) |
| [<span id="fee_estimation-fee_rate_window_size">fee_rate_window_size</span>](#fee_estimation-fee_rate_window_size) | Specifies the window size for the `WeightedMedianFeeRateEstimator`.<br>This determines how many historical fee rate data points are considered<br>when calculating the median fee rate.<br><br>**Notes:**<br>- This setting is primarily relevant when [fee_estimator](#fee_estimation-fee_estimator)  is set to `"FuzzedWeightedMedianFeeRate"`. | `5` |
| [<span id="fee_estimation-log_error">log_error</span>](#fee_estimation-log_error) | If `true`, errors encountered during cost or fee estimation will be logged.<br>This can help diagnose issues with the fee estimation subsystem. | `false` |


## [burnchain]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="burnchain-block_commit_tx_estimated_size">block_commit_tx_estimated_size</span>](#burnchain-block_commit_tx_estimated_size) | Estimated size (in virtual bytes) of a block commit transaction on bitcoin.<br>Used for fee calculation in mining logic by multiplying with the fee rate<br>[satoshis_per_byte](#burnchain-satoshis_per_byte) .<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** virtual bytes | `380` |
| [<span id="burnchain-burn_fee_cap">burn_fee_cap</span>](#burnchain-burn_fee_cap) | The maximum amount (in sats) of "burn commitment" to broadcast for the next<br>block's leader election. Acts as a safety cap to limit the maximum amount<br>spent on mining. It serves as both the target fee and a fallback if dynamic<br>fee calculations fail or cannot be performed.<br><br>This setting can be hot-reloaded from the config file, allowing adjustment<br>without restarting.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** satoshis | `20_000` |
| [<span id="burnchain-chain">chain</span>](#burnchain-chain) | The underlying blockchain used for Proof-of-Transfer.<br><br>**Notes:**<br>- Currently, only `"bitcoin"` is supported. | `"bitcoin"` |
| [<span id="burnchain-chain_id">chain_id</span>](#burnchain-chain_id) | The network-specific identifier used in P2P communication and database initialization.<br><br>**Notes:**<br>- **Warning:** Do not modify this unless you really know what you're doing.<br>- This is intended strictly for testing purposes. | - if [mode](#burnchain-mode)  is `"mainnet"`: `0x00000001`<br>- else: `0x80000000` |
| [<span id="burnchain-commit_anchor_block_within">commit_anchor_block_within</span>](#burnchain-commit_anchor_block_within) | Specifies a mandatory wait period (in milliseconds) after receiving a burnchain tip<br>before the node attempts to build the anchored block for the new tenure.<br>This duration effectively schedules the start of the block-building process<br>relative to the tip's arrival time.<br><br>**Notes:**<br>- This is intended strictly for testing purposes.<br><br>**Units:** milliseconds | `5_000` |
| [<span id="burnchain-epochs">epochs</span>](#burnchain-epochs) | Custom override for the definitions of Stacks epochs (start/end burnchain<br>heights, consensus rules). This setting allows testing specific epoch<br>transitions or custom consensus rules by defining exactly when each epoch<br>starts on bitcoin.<br><br>Epochs define distinct protocol rule sets (consensus rules, execution costs,<br>capabilities). When configured, the list must include all epochs<br>sequentially from "1.0" up to the highest desired epoch, without skipping<br>any intermediate ones. Valid `epoch_name` values currently include:<br>`"1.0"`, `"2.0"`, `"2.05"`, `"2.1"`, `"2.2"`, `"2.3"`, `"2.4"`, `"2.5"`, `"3.0"`, `"3.1"`.<br><br>**Validation Rules:**<br>- Epochs must be provided in strict chronological order (`1.0`, `2.0`, `2.05`...).<br>- `start_height` values must be non-decreasing across the list.<br>- Epoch `"1.0"` must have `start_height = 0`.<br>- The number of defined epochs cannot exceed the maximum supported by the node software.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Configured as a list `[[burnchain.epochs]]` in TOML, each with `epoch_name` (string) and `start_height` (integer Bitcoin block height).<br><br>**Example:**<br><pre><code>[[burnchain.epochs]]&#10;epoch_name = "2.1"&#10;start_height = 150&#10;&#10;[[burnchain.epochs]]&#10;epoch_name = "2.2"&#10;start_height = 200</code></pre> | `None` (uses the standard epoch definitions for the selected [mode](#burnchain-mode) ) |
| [<span id="burnchain-fault_injection_burnchain_block_delay">fault_injection_burnchain_block_delay</span>](#burnchain-fault_injection_burnchain_block_delay) | Fault injection setting for testing. Introduces an artificial delay (in<br>milliseconds) before processing each burnchain block download. Simulates a<br>slow burnchain connection.<br><br>**Notes:**<br>- This is intended strictly for testing purposes.<br><br>**Units:** milliseconds | `0` (no delay) |
| [<span id="burnchain-first_burn_block_hash">first_burn_block_hash</span>](#burnchain-first_burn_block_hash) | Overrides the default starting block hash of the burnchain.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Should be used together with [first_burn_block_height](#burnchain-first_burn_block_height)  and [first_burn_block_timestamp](#burnchain-first_burn_block_timestamp)  for proper operation. | `None` (uses the burnchain's default starting block hash) |
| [<span id="burnchain-first_burn_block_height">first_burn_block_height</span>](#burnchain-first_burn_block_height) | Overrides the default starting bitcoin block height for the node.<br>Allows starting synchronization from a specific historical point in test environments.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Should be used together with [first_burn_block_timestamp](#burnchain-first_burn_block_timestamp)  and [first_burn_block_hash](#burnchain-first_burn_block_hash)  for proper operation. | `None` (uses the burnchain's default starting height for the mode) |
| [<span id="burnchain-first_burn_block_timestamp">first_burn_block_timestamp</span>](#burnchain-first_burn_block_timestamp) | Overrides the default starting block timestamp of the burnchain.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br>- Should be used together with [first_burn_block_height](#burnchain-first_burn_block_height)  and [first_burn_block_hash](#burnchain-first_burn_block_hash)  for proper operation. | `None` (uses the burnchain's default starting timestamp) |
| [<span id="burnchain-leader_key_tx_estimated_size">leader_key_tx_estimated_size</span>](#burnchain-leader_key_tx_estimated_size) | Estimated size (in virtual bytes) of a leader key registration transaction<br>on bitcoin. Used for fee calculation in mining logic by multiplying with the<br>fee rate [satoshis_per_byte](#burnchain-satoshis_per_byte) .<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** virtual bytes | `290` |
| [<span id="burnchain-local_mining_public_key">local_mining_public_key</span>](#burnchain-local_mining_public_key) | The public key associated with the local mining address for the underlying<br>Bitcoin regtest node. Provided as a hex string representing an uncompressed<br>public key.<br><br>It is primarily used in modes that rely on a controlled Bitcoin regtest<br>backend (e.g., "helium", "mocknet", "neon") where the Stacks node itself<br>needs to instruct the Bitcoin node to generate blocks.<br><br>The key is used to derive the Bitcoin address that receives the coinbase<br>rewards when generating blocks on the regtest network.<br><br>**Notes:**<br>- Mandatory if [mode](#burnchain-mode)  is "helium".<br>- This is intended strictly for testing purposes. | `None` |
| [<span id="burnchain-magic_bytes">magic_bytes</span>](#burnchain-magic_bytes) | The network "magic bytes" used to identify packets for the specific bitcoin<br>network instance (e.g., mainnet, testnet, regtest). Must match the magic<br>bytes of the connected bitcoin node.<br><br>These two-byte identifiers help ensure that nodes only connect to peers on the<br>same network type. Common values include:<br>- "X2" for mainnet<br>- "T2" for testnet (xenon)<br>- Other values for specific test networks<br><br>Configured as a 2-character ASCII string (e.g., "X2" for mainnet). | - if [mode](#burnchain-mode)  is `"xenon"`: `"T2"`<br>- else: `"X2"` |
| [<span id="burnchain-max_rbf">max_rbf</span>](#burnchain-max_rbf) | Maximum fee rate multiplier allowed when using Replace-By-Fee (RBF) for<br>bitcoin transactions. Expressed as a percentage of the original<br>[satoshis_per_byte](#burnchain-satoshis_per_byte)  rate (e.g., 150 means the fee rate<br>can be increased up to 1.5x). Used in mining logic for RBF decisions to<br>cap the replacement fee rate.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** percent | `150` |
| [<span id="burnchain-max_unspent_utxos">max_unspent_utxos</span>](#burnchain-max_unspent_utxos) | The maximum number of unspent transaction outputs (UTXOs) to request from<br>the bitcoin node.<br><br>This value is passed as the `maximumCount` parameter to the bitcoin node.<br>It helps manage response size and processing load, particularly relevant<br>for miners querying for available UTXOs to fund operations like block<br>commits or leader key registrations.<br><br>Setting this limit too high might lead to performance issues or timeouts when<br>querying nodes with a very large number of UTXOs. Conversely, setting it too<br>low might prevent the miner from finding enough UTXOs in a single query to<br>meet the required funding amount for a transaction, even if sufficient funds<br>exist across more UTXOs not returned by the limited query.<br><br>**Notes:**<br>- This value must be `<= 1024`.<br>- Only relevant if [[node].miner](#node-miner)  is `true`. | `1024` |
| [<span id="burnchain-mode">mode</span>](#burnchain-mode) | The operational mode or network profile for the Stacks node.<br>This setting determines network parameters (like chain ID, peer version),<br>default configurations, genesis block definitions, and overall node behavior.<br><br>Supported values:<br>- `"mainnet"`: mainnet<br>- `"xenon"`: testnet<br>- `"mocknet"`: regtest<br>- `"helium"`: regtest<br>- `"neon"`: regtest<br>- `"argon"`: regtest<br>- `"krypton"`: regtest<br>- `"nakamoto-neon"`: regtest | `"mocknet"` |
| [<span id="burnchain-password">password</span>](#burnchain-password) | The password for authenticating with the bitcoin node's RPC interface.<br>Required if the bitcoin node requires RPC authentication.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`. | `None` |
| [<span id="burnchain-peer_host">peer_host</span>](#burnchain-peer_host) | The hostname or IP address of the bitcoin node peer.<br><br>This field is required for all node configurations as it specifies where to<br>find the underlying bitcoin node to interact with for PoX operations,<br>block validation, and mining. | `"0.0.0.0"` |
| [<span id="burnchain-peer_port">peer_port</span>](#burnchain-peer_port) | The P2P network port of the bitcoin node specified by [peer_host](#burnchain-peer_host) . | `8333` |
| [<span id="burnchain-peer_version">peer_version</span>](#burnchain-peer_version) | The peer protocol version number used in P2P communication.<br>This parameter cannot be set via the configuration file.<br><br>**Notes:**<br>- **Warning:** Do not modify this unless you really know what you're doing. | - if [mode](#burnchain-mode)  is `"mainnet"`: `402_653_196`<br>- else: `4_207_599_116` |
| [<span id="burnchain-poll_time_secs">poll_time_secs</span>](#burnchain-poll_time_secs) | The interval, in seconds, at which the node polls the bitcoin node for new<br>blocks and state updates.<br><br>The default value of 10 seconds is mainly intended for testing purposes.<br>It's suggested to set this to a higher value for mainnet, e.g., 300 seconds<br>(5 minutes).<br><br>**Units:** seconds | `10` |
| [<span id="burnchain-pox_2_activation">pox_2_activation</span>](#burnchain-pox_2_activation) | Sets a custom burnchain height for PoX-2 activation (for testing).<br><br>This affects two key transitions:<br>1. The block height at which PoX v1 lockups are automatically unlocked.<br>2. The block height from which PoX reward set calculations switch to PoX v2 rules.<br><br>**Behavior:**<br>- This value directly sets the auto unlock height for PoX v1 lockups before<br>  transition to PoX v2. This also defines the burn height at which PoX reward<br>  sets are calculated using PoX v2 rather than v1.<br>- If custom [epochs](#burnchain-epochs)  are provided:<br>&nbsp;&nbsp;- This value is used to validate that Epoch 2.1's start height is ≤ this value.<br>&nbsp;&nbsp;- However, the height specified in `epochs` for Epoch 2.1 takes precedence.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes. | `None` |
| [<span id="burnchain-pox_prepare_length">pox_prepare_length</span>](#burnchain-pox_prepare_length) | Overrides the length (in bitcoin blocks) of the PoX prepare phase.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br><br>**Units:** bitcoin blocks | `None` (uses the standard prepare phase length for the mode) |
| [<span id="burnchain-pox_reward_length">pox_reward_length</span>](#burnchain-pox_reward_length) | Overrides the length (in bitcoin blocks) of the PoX reward cycle.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes.<br><br>**Units:** bitcoin blocks | `None` (uses the standard reward cycle length for the mode) |
| [<span id="burnchain-process_exit_at_block_height">process_exit_at_block_height</span>](#burnchain-process_exit_at_block_height) | Optional bitcoin block height at which the Stacks node process should<br>gracefully exit. When bitcoin reaches this height, the node logs a message<br>and initiates a graceful shutdown.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes. | `None` |
| [<span id="burnchain-rbf_fee_increment">rbf_fee_increment</span>](#burnchain-rbf_fee_increment) | The incremental amount (in sats/vByte) to add to the previous transaction's<br>fee rate for RBF bitcoin transactions.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** sats/vByte | `5` |
| [<span id="burnchain-rpc_port">rpc_port</span>](#burnchain-rpc_port) | The RPC port of the bitcoin node specified by [peer_host](#burnchain-peer_host) . | `8332` |
| [<span id="burnchain-rpc_ssl">rpc_ssl</span>](#burnchain-rpc_ssl) | Flag indicating whether to use SSL/TLS when connecting to the bitcoin node's<br>RPC interface. | `false` |
| [<span id="burnchain-satoshis_per_byte">satoshis_per_byte</span>](#burnchain-satoshis_per_byte) | The default fee rate in sats/vByte to use when estimating fees for miners<br>to submit bitcoin transactions (like block commits or leader key registrations).<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`.<br><br>**Units:** sats/vByte | `50` |
| [<span id="burnchain-timeout">timeout</span>](#burnchain-timeout) | Timeout duration, in seconds, for RPC calls made to the bitcoin node.<br>Configures the timeout on the underlying HTTP client.<br><br>**Units:** seconds | `60` |
| [<span id="burnchain-username">username</span>](#burnchain-username) | The username for authenticating with the bitcoin node's RPC interface.<br>Required if the bitcoin node requires RPC authentication.<br><br>**Notes:**<br>- Only relevant if [[node].miner](#node-miner)  is `true`. | `None` |
| [<span id="burnchain-wallet_name">wallet_name</span>](#burnchain-wallet_name) | Specifies the name of the Bitcoin wallet to use within the connected bitcoin<br>node. Used to interact with a specific named wallet if the bitcoin node<br>manages multiple wallets.<br><br>If the specified wallet doesn't exist, the node will attempt to create it via<br>the `createwallet` RPC call. This is particularly useful for miners who need<br>to manage separate wallets.<br><br>**Notes:**<br>- Primarily relevant for miners interacting with multi-wallet Bitcoin nodes. | `""` (empty string, implying the default wallet or no specific wallet needed) |
| ~~[<span id="burnchain-affirmation_overrides">affirmation_overrides</span>](#burnchain-affirmation_overrides)~~ | Overrides for the burnchain block affirmation map for specific reward cycles.<br>Allows manually setting the miner affirmation ('p'resent/'n'ot-present/'a'bsent)<br>map for a given cycle, bypassing the map normally derived from sortition results.<br><br>Special defaults are added when [mode](#burnchain-mode)  is "xenon", but<br>config entries take precedence. At startup, these overrides are written to<br>the `BurnchainDB` (`overrides` table).<br><br>**Notes:**<br>- Primarily used for testing or recovering from network issues.<br>- Configured as a list `[[burnchain.affirmation_overrides]]` in TOML, each with `reward_cycle` (integer) and `affirmation` (string of 'p'/'n'/'a', length `reward_cycle - 1`).<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Example:**<br><pre><code>[[burnchain.affirmation_overrides]]&#10;reward_cycle = 413&#10;affirmation = "pna..." # Must be 412 chars long</code></pre> | Empty map |
| ~~[<span id="burnchain-ast_precheck_size_height">ast_precheck_size_height</span>](#burnchain-ast_precheck_size_height)~~ | Override for the burnchain height activating stricter AST size checks<br>pre-epoch 3.0 for testing purposes.<br><br>Used pre-epoch 3.0 to control activation before it became standard (at burn<br>height `752000`). Ignored in standard production builds as the underlying<br>mechanism is disabled unless the `testing` feature is active.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. | `None` |
| ~~[<span id="burnchain-sunset_end">sunset_end</span>](#burnchain-sunset_end)~~ | Overrides the bitcoin height, non-inclusive, at which the PoX sunset period<br>ends in epochs before 2.1. After this height, Stacking rewards are disabled<br>completely. This parameter works together with `sunset_start` to define the<br>full sunset transition period for PoX.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes for epochs before 2.1.<br><br>**⚠️ DEPRECATED:** The sunset phase was removed in Epoch 2.1. | `None` (uses the standard sunset end height for the mode) |
| ~~[<span id="burnchain-sunset_start">sunset_start</span>](#burnchain-sunset_start)~~ | Overrides the bitcoin height at which the PoX sunset period begins in epochs<br>before 2.1. The sunset period represents a planned phase-out of the PoX<br>mechanism. During this period, stacking rewards gradually decrease,<br>eventually ceasing entirely. This parameter allows testing the PoX sunset<br>transition by explicitly setting its start height.<br><br>**Notes:**<br>- Applied only if [mode](#burnchain-mode)  is not "mainnet".<br>- This is intended strictly for testing purposes for epochs before 2.1.<br><br>**⚠️ DEPRECATED:** The sunset phase was removed in Epoch 2.1. | `None` (uses the standard sunset start height for the mode) |


## [node]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="node-always_use_affirmation_maps">always_use_affirmation_maps</span>](#node-always_use_affirmation_maps) | Controls if Stacks Epoch 2.1+ affirmation map logic should be applied even<br>before Epoch 2.1.<br>- If `true` (default), the node consistently uses the newer (Epoch 2.1) rules<br>  for PoX anchor block validation and affirmation-based reorg handling, even in<br>  earlier epochs.<br>- If `false`, the node strictly follows the rules defined for the specific epoch<br>  it is currently processing, only applying 2.1+ logic from Epoch 2.1 onwards.<br>Differences in this setting between nodes prior to Epoch 2.1 could lead to<br>consensus forks. | `true` |
| [<span id="node-assume_present_anchor_blocks">assume_present_anchor_blocks</span>](#node-assume_present_anchor_blocks) | Controls if the node must strictly wait for any PoX anchor block selected by<br>the core consensus mechanism.<br>- If `true`: Halts burnchain processing immediately whenever a selected anchor<br>  block is missing locally (`SelectedAndUnknown` status), regardless of<br>  affirmation status.<br>- If `false` (primarily for testing): Skips this immediate halt, allowing<br>  processing to proceed to affirmation map checks.<br>Normal operation requires this to be `true`; setting to `false` will likely<br>break consensus adherence.<br><br>**Notes:**<br>- This parameter cannot be set via the configuration file; it must be modified programmatically.<br>- This is intended strictly for testing purposes.<br>- The halt check runs *before* affirmation checks.<br>- In Nakamoto (Epoch 3.0+), all prepare phases have anchor blocks. | `true` |
| [<span id="node-bootstrap_node">bootstrap_node</span>](#node-bootstrap_node) | A list of initial peer nodes used to bootstrap connections into the Stacks P2P<br>network. Peers are specified in a configuration file as comma-separated<br>strings in the format `"PUBKEY@IP:PORT"` or `"PUBKEY@HOSTNAME:PORT"`. DNS<br>hostnames are resolved during configuration loading.<br><br>**Example:**<br><pre><code>bootstrap_node = "pubkey1@example.com:30444,pubkey2@192.168.1.100:20444"</code></pre> | `[]` (empty vector) |
| [<span id="node-chain_liveness_poll_time_secs">chain_liveness_poll_time_secs</span>](#node-chain_liveness_poll_time_secs) | The polling interval, in seconds, for the background thread that monitors<br>chain liveness. This thread periodically wakes up the main coordinator to<br>check for chain progress or other conditions requiring action.<br><br>**Units:** seconds | `300` (5 minutes) |
| [<span id="node-data_url">data_url</span>](#node-data_url) | The publicly accessible URL that this node advertises to peers during the P2P<br>handshake as its HTTP RPC endpoint. Other nodes or services might use this URL<br>to query the node's API.<br><br>**Notes:**<br>- Example: For rpc_bind="0.0.0.0:20443", data_url becomes "http://0.0.0.0:20443". | Derived by adding "http://" prefix to [rpc_bind](#node-rpc_bind)  value. |
| [<span id="node-deny_nodes">deny_nodes</span>](#node-deny_nodes) | A list of peer addresses that this node should explicitly deny connections from.<br>Peers are specified as comma-separated strings in the format "IP:PORT" or<br>"HOSTNAME:PORT" in the configuration file. DNS hostnames are resolved during<br>configuration loading.<br><br>**Example:**<br><pre><code>deny_nodes = "192.168.1.100:20444,badhost.example.com:20444"</code></pre> | `[]` (empty vector) |
| [<span id="node-fault_injection_block_push_fail_probability">fault_injection_block_push_fail_probability</span>](#node-fault_injection_block_push_fail_probability) | Fault injection setting for testing purposes. If set to `Some(p)`, where `p` is<br>between 0 and 100, the node will have a `p` percent chance of intentionally<br>*not* pushing a newly processed block to its peers.<br><br>**Notes:**<br>- Values: 0-100 (percentage). | `None` (no fault injection) |
| [<span id="node-fault_injection_hide_blocks">fault_injection_hide_blocks</span>](#node-fault_injection_hide_blocks) | Fault injection setting for testing purposes. If `true`, the node's chainstate<br>database access layer may intentionally fail to retrieve block data, even if it<br>exists, simulating block hiding or data unavailability.<br><br>**Notes:**<br>- This parameter cannot be set via the configuration file; it must be modified programmatically. | `false` |
| [<span id="node-local_peer_seed">local_peer_seed</span>](#node-local_peer_seed) | The private key seed, provided as a hex string in the config file, used<br>specifically for the node's identity and message signing within the P2P<br>networking layer. This is separate from the main [seed](#node-seed) . | Randomly generated 32 bytes |
| [<span id="node-marf_cache_strategy">marf_cache_strategy</span>](#node-marf_cache_strategy) | The strategy to use for MARF trie node caching in memory.<br>Controls the trade-off between memory usage and performance for state access.<br><br>Possible values:<br>- `"noop"`: No caching (least memory).<br>- `"everything"`: Cache all nodes (most memory, potentially fastest).<br>- `"node256"`: Cache only larger `TrieNode256` nodes.<br><br>If the value is `None` or an unrecognized string, it defaults to `"noop"`. | `None` (effectively `"noop"`) |
| [<span id="node-marf_defer_hashing">marf_defer_hashing</span>](#node-marf_defer_hashing) | Controls the timing of hash calculations for MARF trie nodes.<br>- If `true`, hashes are calculated only when the MARF is flushed to disk<br>  (deferred hashing).<br>- If `false`, hashes are calculated immediately as leaf nodes are inserted or<br>  updated (immediate hashing).<br>Deferred hashing might improve write performance. | `true` |
| [<span id="node-miner">miner</span>](#node-miner) | Flag indicating whether this node should activate its mining logic and attempt to<br>produce Stacks blocks. Setting this to `true` typically requires providing<br>necessary private keys (either [seed](#node-seed)  or [[miner].mining_key](#miner-mining_key) ).<br>It also influences default behavior for settings like<br>[require_affirmed_anchor_blocks](#node-require_affirmed_anchor_blocks) . | `false` |
| [<span id="node-mock_mining">mock_mining</span>](#node-mock_mining) | Enables a simulated mining mode, primarily for local testing and development.<br>When `true`, the node may generate blocks locally without participating in the<br>real bitcoin consensus or P2P block production process.<br><br>**Notes:**<br>- Only relevant if [miner](#node-miner)  is `true`. | `false` |
| [<span id="node-name">name</span>](#node-name) | Human-readable name for the node. Primarily used for identification in testing<br>environments (e.g., deriving log file names, temporary directory names). | `"helium-node"` |
| [<span id="node-next_initiative_delay">next_initiative_delay</span>](#node-next_initiative_delay) | Controls how frequently, in milliseconds, the Nakamoto miner's relay thread<br>polls for work or takes periodic actions when idle (e.g., checking for new<br>burnchain blocks). A default value of 10 seconds is reasonable on mainnet<br>(where bitcoin blocks are ~10 minutes). A lower value might be useful in<br>other environments with faster burn blocks.<br><br>**Units:** milliseconds | `10_000` (10 seconds) |
| [<span id="node-p2p_address">p2p_address</span>](#node-p2p_address) | The publicly accessible IPv4 address and port that this node advertises to peers<br>for P2P connections. This might differ from [p2p_bind](#node-p2p_bind)  if the<br>node is behind NAT or a proxy.<br><br>**Notes:**<br>- Example: For rpc_bind="0.0.0.0:20443", p2p_address becomes "0.0.0.0:20443".<br>- The default value derivation might be unexpected, potentially using the [rpc_bind](#node-rpc_bind)  address; explicit configuration is recommended if needed. | Derived directly from [rpc_bind](#node-rpc_bind)  value. |
| [<span id="node-p2p_bind">p2p_bind</span>](#node-p2p_bind) | The IPv4 address and port (e.g., "0.0.0.0:20444") on which the node's P2P<br>networking service should bind and listen for incoming connections from other peers. | `"0.0.0.0:20444"` |
| [<span id="node-prometheus_bind">prometheus_bind</span>](#node-prometheus_bind) | Optional network address and port (e.g., "127.0.0.1:9153") for binding the<br>Prometheus metrics server. If set, the node will start an HTTP server on this<br>address to expose internal metrics for scraping by a Prometheus instance. | `None` (Prometheus server disabled) |
| [<span id="node-require_affirmed_anchor_blocks">require_affirmed_anchor_blocks</span>](#node-require_affirmed_anchor_blocks) | Controls if the node must wait for locally missing but burnchain-affirmed PoX<br>anchor blocks. If an anchor block is confirmed by the affirmation map but not<br>yet processed by this node:<br>- If `true`: Burnchain processing halts until the affirmed block is acquired.<br>  Ensures strict adherence to the affirmed canonical chain, typical for<br>  followers.<br>- If `false`: Burnchain processing continues without waiting. Allows miners to<br>  operate optimistically but may necessitate unwinding later if the affirmed<br>  block alters the chain state. | Derived from the inverse of [miner](#node-miner)  value. |
| [<span id="node-rpc_bind">rpc_bind</span>](#node-rpc_bind) | The IPv4 address and port (e.g., "0.0.0.0:20443") on which the node's HTTP RPC<br>server should bind and listen for incoming API requests. | `"0.0.0.0:20443"` |
| [<span id="node-seed">seed</span>](#node-seed) | The node's Bitcoin wallet private key, provided as a hex string in the config file.<br>Used to initialize the node's keychain for signing operations.<br>If [[miner].mining_key](#miner-mining_key)  is not set, this seed may also be used for<br>mining-related signing.<br><br>**Notes:**<br>- Required if [miner](#node-miner)  is `true` and [[miner].mining_key](#miner-mining_key)  is absent. | Randomly generated 32 bytes |
| [<span id="node-stacker">stacker</span>](#node-stacker) | Setting this to `true` enables the node to replicate the miner and signer<br>Stacker DBs required for signing, and is required if the node is connected to a<br>signer. | `false` |
| [<span id="node-stacker_dbs">stacker_dbs</span>](#node-stacker_dbs) | A list of specific StackerDB contracts (identified by their qualified contract<br>identifiers, e.g., "SP000000000000000000002Q6VF78.pox-3") that this node<br>should actively replicate.<br><br>**Notes:**<br>- Values are strings representing qualified contract identifiers.<br><br>**Example:**<br><pre><code>stacker_dbs = [&#10;  "SP000000000000000000002Q6VF78.pox-3",&#10;  "SP2C2YFP12AJZB4M4KUPSTMZQR0SNHNPH204SCQJM.stx-oracle-v1"&#10;]</code></pre> | - if [miner](#node-miner)  is `true` or [stacker](#node-stacker)  is `true`:<br>  relevant system contracts (e.g., `.miners`, `.signers-*`) are<br>  automatically added in addition to any contracts specified in the<br>  configuration file.<br>- else: defaults to an empty list `[]`. |
| [<span id="node-txindex">txindex</span>](#node-txindex) | Enables the transaction index, which maps transaction IDs to the blocks<br>containing them. Setting this to `true` allows the use of RPC endpoints<br>that look up transactions by ID (e.g., `/extended/v1/tx/{txid}`), but<br>requires substantial additional disk space for the index database. | `false` |
| [<span id="node-use_test_genesis_chainstate">use_test_genesis_chainstate</span>](#node-use_test_genesis_chainstate) | If set to `true`, the node initializes its state using an alternative test<br>genesis block definition, loading different initial balances, names, and<br>lockups than the standard network genesis.<br><br>**Notes:**<br>- This is intended strictly for testing purposes and is disallowed on mainnet. | `None` (uses standard network genesis) |
| [<span id="node-wait_time_for_blocks">wait_time_for_blocks</span>](#node-wait_time_for_blocks) | When operating as a miner, this specifies the maximum time (in milliseconds)<br>the node waits after detecting a new burnchain block to synchronize corresponding<br>Stacks block data from the network before resuming mining attempts.<br>If synchronization doesn't complete within this duration, mining resumes anyway<br>to prevent stalling. This setting is loaded by all nodes but primarily affects<br>miner behavior within the relayer thread.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |
| [<span id="node-working_dir">working_dir</span>](#node-working_dir) | The file system absolute path to the node's working directory.<br>All persistent data, including chainstate, burnchain databases, and potentially<br>other stores, will be located within this directory. This path can be<br>overridden by setting the `STACKS_WORKING_DIR` environment variable.<br><br>**Notes:**<br>- For persistent mainnet or testnet nodes, this path must be explicitly configured to a non-temporary location. | `/tmp/stacks-node-{current_timestamp}` |
| ~~[<span id="node-max_microblocks">max_microblocks</span>](#node-max_microblocks)~~ | The maximum number of microblocks allowed per Stacks block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+. | `65535` (u16::MAX) |
| ~~[<span id="node-microblock_frequency">microblock_frequency</span>](#node-microblock_frequency)~~ | How often to attempt producing microblocks, in milliseconds.<br><br>**Notes:**<br>- Only applies when [mine_microblocks](#node-mine_microblocks)  is true and before Epoch 2.5.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |
| ~~[<span id="node-mine_microblocks">mine_microblocks</span>](#node-mine_microblocks)~~ | Enable microblock mining.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+. | `true` |
| ~~[<span id="node-mock_mining_output_dir">mock_mining_output_dir</span>](#node-mock_mining_output_dir)~~ | If [mock_mining](#node-mock_mining)  is enabled, this specifies an optional directory<br>path where the generated mock Stacks blocks will be saved. (pre-Nakamoto)<br>The path is canonicalized on load.<br><br>**⚠️ DEPRECATED:** This setting was only used in the neon node and is ignored in Epoch 3.0+. | `None` |
| ~~[<span id="node-pox_sync_sample_secs">pox_sync_sample_secs</span>](#node-pox_sync_sample_secs)~~ | Sampling interval in seconds for the PoX synchronization watchdog thread<br>(pre-Nakamoto). Determines how often the watchdog checked PoX state<br>consistency in the Neon run loop.<br><br>**⚠️ DEPRECATED:** Unused after the Nakamoto upgrade. This setting is ignored in Epoch 3.0+.<br><br>**Units:** seconds | `30` |
| ~~[<span id="node-wait_time_for_microblocks">wait_time_for_microblocks</span>](#node-wait_time_for_microblocks)~~ | Cooldown period after a microblock is produced, in milliseconds.<br><br>**Notes:**<br>- Only applies when [mine_microblocks](#node-mine_microblocks)  is true and before Epoch 2.5.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 2.5+.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |


## [miner]

| Parameter | Description | Default |
|-----------|-------------|----------|
| [<span id="miner-activated_vrf_key_path">activated_vrf_key_path</span>](#miner-activated_vrf_key_path) | Path to a file for storing and loading the currently active, registered VRF leader key.<br><br>Loading: On startup or when needing to register a key, if this path is set,<br>the relayer first attempts to load a serialized `RegisteredKey` from this<br>file. If successful, it uses the loaded key and skips the on-chain VRF key<br>registration transaction, saving time and fees.<br>Saving: After a new VRF key registration transaction is confirmed and<br>activated on the burnchain, if this path is set, the node saves the details<br>of the newly activated `RegisteredKey` to this file. This allows the<br>miner to persist its active VRF key across restarts.<br>If the file doesn't exist during load, or the path is `None`, the node<br>proceeds with a new registration. | `None` |
| [<span id="miner-block_commit_delay">block_commit_delay</span>](#miner-block_commit_delay) | Time in milliseconds to wait for a Nakamoto block after seeing a burnchain<br>block before submitting a block commit.<br><br>After observing a new burnchain block, the miner's relayer waits for this<br>duration before submitting its next block commit transaction to Bitcoin.<br>This delay provides an opportunity for a new Nakamoto block (produced by the<br>winner of the latest sortition) to arrive. Waiting helps avoid situations<br>where the relayer immediately submits a commit that needs to be replaced<br>via RBF if a new Stacks block appears shortly after. This delay is skipped<br>if the new burnchain blocks leading to the tip contain no sortitions.<br><br>**Units:** milliseconds | `40_000` |
| [<span id="miner-block_rejection_timeout_steps">block_rejection_timeout_steps</span>](#miner-block_rejection_timeout_steps) | Defines adaptive timeouts for waiting for signer responses, based on the<br>accumulated weight of rejections.<br><br>Configured as a map where keys represent rejection count thresholds in<br>percentage, and values are the timeout durations (in seconds) to apply when<br>the rejection count reaches or exceeds that key but is less than the next key.<br><br>When a miner proposes a block, it waits for signer responses (approvals or<br>rejections). The SignerCoordinator tracks the total weight of received<br>rejections. It uses this map to determine the current timeout duration. It<br>selects the timeout value associated with the largest key in the map that is<br>less than or equal to the current accumulated rejection weight. If this<br>timeout duration expires before a decision is reached, the coordinator<br>signals a timeout. This prompts the miner to potentially retry proposing the<br>block. As more rejections come in, the applicable timeout step might change<br>(likely decrease), allowing the miner to abandon unviable proposals faster.<br><br>A key for 0 (zero rejections) must be defined, representing the initial<br>timeout when no rejections have been received.<br><br>**Notes:**<br>- Keys are rejection weight percentages (0-100).<br>- Values are timeout durations.<br><br>**Example:**<br><pre><code># Keys are rejection counts (as strings), values are timeouts in seconds.&#10;[miner.block_rejection_timeout_steps]&#10;"0" = 180&#10;"10" = 90&#10;"20" = 45&#10;"30" = 0</code></pre> | `{ 0: 180, 10: 90, 20: 45, 30: 0 }` (times in seconds) |
| [<span id="miner-block_reward_recipient">block_reward_recipient</span>](#miner-block_reward_recipient) | Optional recipient for the coinbase block reward, overriding the default miner address.<br><br>By default (`None`), the reward is sent to the miner's primary address<br>([[node].seed](#node-seed) ). If set to some principal address *and* the current<br>Stacks epoch is > 2.1, the reward will be directed to the specified<br>address instead. | `None` |
| [<span id="miner-candidate_retry_cache_size">candidate_retry_cache_size</span>](#miner-candidate_retry_cache_size) | Max size (in *number* of items) of transaction candidates to hold in the in-memory<br>retry cache.<br><br>This cache stores transactions encountered during a `GlobalFeeRate` mempool<br>walk whose nonces are currently too high for immediate processing. These<br>candidates are prioritized for reconsideration later within the *same* walk,<br>potentially becoming valid if other processed transactions update the<br>expected nonces.<br><br>A larger cache retains more potentially valid future candidates but uses more<br>memory. This setting is primarily relevant for the `GlobalFeeRate` strategy.<br><br>**Notes:**<br>- Each element `crate::core::mempool::MemPoolTxInfoPartial` is currently 112 bytes.<br><br>**Units:** items | `1048576` |
| [<span id="miner-empty_mempool_sleep_time">empty_mempool_sleep_time</span>](#miner-empty_mempool_sleep_time) | The amount of time in milliseconds that the miner should sleep in between<br>attempts to mine a block when the mempool is empty.<br><br>This prevents the miner from busy-looping when there are no pending<br>transactions, conserving CPU resources. During this sleep, the miner still<br>checks burnchain tip changes.<br><br>**Units:** milliseconds | `2_500` |
| [<span id="miner-filter_origins">filter_origins</span>](#miner-filter_origins) | A comma separated list of Stacks addresses to whitelist so that only<br>transactions from these addresses should be considered during the mempool walk<br>for block building. If this list is non-empty, any transaction whose origin<br>address is *not* in this set will be skipped.<br><br>This allows miners to prioritize transactions originating from specific accounts that are<br>important to them.<br>Configured as a comma-separated string of standard Stacks addresses<br>(e.g., "ST123...,ST456...") in the configuration file.<br><br>**Example:**<br><pre><code>filter_origins = "ST2QKZ4FKHAH1NQKYKYAYZPY440FEPK7GZ1R5HBP2,ST319CF5WV77KYR1H3GT0GZ7B8Q4AQPY42ETP1VPF"</code></pre> | Empty set (all origins are considered). |
| [<span id="miner-first_rejection_pause_ms">first_rejection_pause_ms</span>](#miner-first_rejection_pause_ms) | Time in milliseconds to pause after receiving the first threshold rejection,<br>before proposing a new block.<br><br>When a miner's block proposal fails to gather enough signatures from the<br>signers for the first time at a given height, the miner will pause for this<br>duration before attempting to mine and propose again.<br><br>**Units:** milliseconds | `5_000` |
| [<span id="miner-max_execution_time_secs">max_execution_time_secs</span>](#miner-max_execution_time_secs) | Defines the maximum execution time (in seconds) allowed for a single contract call transaction.<br><br>When processing a transaction (contract call or smart contract deployment),<br>if this option is set, and the execution time exceeds this limit, the<br>transaction processing fails with an `ExecutionTimeout` error, and the<br>transaction is skipped. This prevents potentially long-running or<br>infinite-loop transactions from blocking block production.<br><br>**Units:** seconds | `None` (no execution time limit) |
| [<span id="miner-mempool_walk_strategy">mempool_walk_strategy</span>](#miner-mempool_walk_strategy) | Strategy for selecting the next transaction candidate from the mempool.<br>Controls prioritization between maximizing immediate fee capture vs. ensuring<br>transaction nonce order for account progression and processing efficiency.<br><br>See `MemPoolWalkStrategy` for variant details.<br><br>Possible values (use variant names for configuration):<br>- `"GlobalFeeRate"`: Selects the transaction with the highest fee rate globally.<br>- `"NextNonceWithHighestFeeRate"`: Selects the highest-fee transaction among those<br>  matching the next expected nonce for sender/sponsor accounts. | `"GlobalFeeRate"` |
| [<span id="miner-min_time_between_blocks_ms">min_time_between_blocks_ms</span>](#miner-min_time_between_blocks_ms) | The minimum time to wait between mining blocks in milliseconds. The value<br>must be greater than or equal to 1000 ms because if a block is mined<br>within the same second as its parent, it will be rejected by the signers.<br><br>This check ensures compliance with signer rules that prevent blocks with<br>identical timestamps (at second resolution) to their parents. If a lower<br>value is configured, 1000 ms is used instead.<br><br>**Units:** milliseconds | `1_000` |
| [<span id="miner-mining_key">mining_key</span>](#miner-mining_key) | The private key (Secp256k1) used for signing blocks, provided as a hex string.<br><br>This key must be present at runtime for mining operations to succeed. | - if the `[miner]` section *is present* in the config file: [[node].seed](#node-seed) <br>- else: `None` |
| [<span id="miner-nakamoto_attempt_time_ms">nakamoto_attempt_time_ms</span>](#miner-nakamoto_attempt_time_ms) | Maximum time (in milliseconds) the miner spends selecting transactions from<br>the mempool when assembling a Nakamoto block. Once this duration is exceeded,<br>the miner stops adding transactions and finalizes the block with those<br>already selected.<br><br>**Units:** milliseconds | `5_000` (5 seconds) |
| [<span id="miner-nonce_cache_size">nonce_cache_size</span>](#miner-nonce_cache_size) | Max size (in bytes) of the in-memory cache for storing expected account nonces.<br><br>This cache accelerates mempool processing (e.g., during block building) by<br>storing the anticipated next nonce for accounts, reducing expensive lookups<br>into the node's state (MARF trie). A larger cache can improve performance<br>for workloads involving many unique accounts but increases memory consumption.<br><br>**Notes:**<br>- Must be configured to a value greater than 0.<br><br>**Units:** bytes | `1048576` (1 MiB) |
| [<span id="miner-probability_pick_no_estimate_tx">probability_pick_no_estimate_tx</span>](#miner-probability_pick_no_estimate_tx) | Probability (percentage, 0-100) of prioritizing a transaction without a<br>known fee rate during candidate selection.<br><br>Only effective when `mempool_walk_strategy` is `GlobalFeeRate`. Helps ensure<br>transactions lacking fee estimates are periodically considered alongside<br>high-fee ones, preventing potential starvation. A value of 0 means never<br>prioritize them first, 100 means always prioritize them first (if available).<br><br>**Notes:**<br>- Values: 0-100.<br><br>**Units:** percent | `25` (25% chance) |
| [<span id="miner-replay_transactions">replay_transactions</span>](#miner-replay_transactions) | TODO: remove this option when its no longer a testing feature and it becomes default behaviour<br>The miner will attempt to replay transactions that a threshold number of signers are expecting in the next block | **Required** |
| [<span id="miner-segwit">segwit</span>](#miner-segwit) | If possible, mine with a p2wpkh address. | `false` |
| [<span id="miner-subsequent_rejection_pause_ms">subsequent_rejection_pause_ms</span>](#miner-subsequent_rejection_pause_ms) | Time in milliseconds to pause after receiving subsequent threshold rejections,<br>before proposing a new block.<br><br>If a miner's block proposal is rejected multiple times at the same height<br>(after the first rejection), this potentially longer pause duration is used<br>before retrying. This gives more significant time for network state changes<br>or signer coordination.<br><br>**Units:** milliseconds | `10_000` |
| [<span id="miner-tenure_cost_limit_per_block_percentage">tenure_cost_limit_per_block_percentage</span>](#miner-tenure_cost_limit_per_block_percentage) | The percentage of the remaining tenure cost limit to consume each block.<br><br>This setting limits the execution cost (Clarity cost) a single Nakamoto block<br>can incur, expressed as a percentage of the *remaining* cost budget for the<br>current mining tenure. For example, if set to 25, a block can use at most<br>25% of the tenure's currently available cost limit. This allows miners to<br>spread the tenure's total execution budget across multiple blocks rather than<br>potentially consuming it all in the first block.<br><br>**Notes:**<br>- Values: 1-100.<br>- Setting to 100 effectively disables this per-block limit, allowing a block to use the entire remaining tenure budget.<br><br>**Units:** percent | `25` |
| [<span id="miner-tenure_extend_cost_threshold">tenure_extend_cost_threshold</span>](#miner-tenure_extend_cost_threshold) | Percentage of block budget that must be used before attempting a time-based tenure extend.<br><br>This sets a minimum threshold for the accumulated execution cost within a<br>tenure before a time-based tenure extension ([tenure_timeout](#miner-tenure_timeout) )<br>can be initiated. The miner checks if the proportion of the total tenure<br>budget consumed so far exceeds this percentage. If the cost usage is below<br>this threshold, a time-based extension will not be attempted, even if the<br>[tenure_timeout](#miner-tenure_timeout)  duration has elapsed. This prevents miners<br>from extending tenures very early if they have produced only low-cost blocks.<br><br>**Notes:**<br>- Values: 0-100.<br><br>**Units:** percent | `50` |
| [<span id="miner-tenure_extend_poll_timeout">tenure_extend_poll_timeout</span>](#miner-tenure_extend_poll_timeout) | Duration to wait in-between polling the sortition DB to see if we need to<br>extend the ongoing tenure (e.g. because the current sortition is empty or invalid).<br><br>After the relayer determines that a tenure extension might be needed but<br>cannot proceed immediately (e.g., because a miner thread is already active<br>for the current burn view), it will wait for this duration before<br>re-checking the conditions for tenure extension.<br><br>**Units:** seconds | `1` |
| [<span id="miner-tenure_extend_wait_timeout">tenure_extend_wait_timeout</span>](#miner-tenure_extend_wait_timeout) | Duration to wait before trying to continue a tenure because the next miner<br>did not produce blocks.<br><br>If the node was the winner of the previous sortition but not the most recent<br>one, the relayer waits for this duration before attempting to extend its own<br>tenure. This gives the new winner of the most recent sortition a grace period<br>to produce their first block. Also used in scenarios with empty sortitions<br>to give the winner of the *last valid* sortition time to produce a block<br>before the current miner attempts an extension.<br><br>**Units:** milliseconds | `120_000` |
| [<span id="miner-tenure_timeout">tenure_timeout</span>](#miner-tenure_timeout) | Duration to wait before attempting to issue a time-based tenure extend.<br><br>A miner can proactively attempt to extend its tenure if a significant amount<br>of time has passed since the last tenure change, even without an explicit<br>trigger like an empty sortition. If the time elapsed since the last tenure<br>change exceeds this value, and the signer coordinator indicates an extension<br>is timely, and the cost usage threshold ([tenure_extend_cost_threshold](#miner-tenure_extend_cost_threshold) )<br>is met, the miner will include a tenure extension transaction in its next block.<br><br>**Units:** seconds | `180` |
| [<span id="miner-txs_to_consider">txs_to_consider</span>](#miner-txs_to_consider) | Specifies which types of transactions the miner should consider including in a<br>block during the mempool walk process. Transactions of types not included in<br>this set will be skipped.<br><br>This allows miners to exclude specific transaction categories.<br>Configured as a comma-separated string of transaction type names in the configuration file.<br><br>Accepted values correspond to variants of `MemPoolWalkTxTypes`:<br>- `"TokenTransfer"`<br>- `"SmartContract"`<br>- `"ContractCall"`<br><br>**Example:**<br><pre><code>txs_to_consider = "TokenTransfer,ContractCall"</code></pre> | All transaction types are considered (equivalent to [`MemPoolWalkTxTypes::all()`]). |
| [<span id="miner-wait_for_block_download">wait_for_block_download</span>](#miner-wait_for_block_download) | Wait for a downloader pass before mining.<br>This can only be disabled in testing; it can't be changed in the config file. | `true` |
| ~~[<span id="miner-fast_rampup">fast_rampup</span>](#miner-fast_rampup)~~ | Controls how the miner estimates its win probability when checking for underperformance.<br><br>This estimation is used in conjunction with [target_win_probability](#miner-target_win_probability)  and<br>[underperform_stop_threshold](#miner-underperform_stop_threshold)  to decide whether to pause<br>mining due to low predicted success rate.<br><br>- If `true`: The win probability estimation looks at projected spend<br>  distributions ~6 blocks into the future. This might help the miner adjust<br>  its spending more quickly based on anticipated competition changes.<br>- If `false`: The win probability estimation uses the currently observed<br>  spend distribution for the next block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode and by the<br>`get-spend-amount` cli subcommand. | `false` |
| ~~[<span id="miner-first_attempt_time_ms">first_attempt_time_ms</span>](#miner-first_attempt_time_ms)~~ | Time to wait (in milliseconds) before the first attempt to mine a block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** milliseconds | `10` |
| ~~[<span id="miner-max_reorg_depth">max_reorg_depth</span>](#miner-max_reorg_depth)~~ | Defines the maximum depth (in Stacks blocks) the miner considers when<br>evaluating potential chain tips when selecting the best tip to mine the next<br>block on.<br><br>The miner analyzes candidate tips within this depth from the highest known<br>tip. It selects the "nicest" tip, often defined as the one that minimizes<br>chain reorganizations or orphans within this lookback window. A lower value<br>restricts the analysis to shallower forks, while a higher value considers<br>deeper potential reorganizations.<br><br>This setting influences which fork the miner chooses to build upon if multiple valid tips exist.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode and the<br>`pick-best-tip` cli subcommand. | `3` |
| ~~[<span id="miner-microblock_attempt_time_ms">microblock_attempt_time_ms</span>](#miner-microblock_attempt_time_ms)~~ | Time to wait (in milliseconds) to mine a microblock.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** milliseconds | `30_000` (30 seconds) |
| ~~[<span id="miner-min_tx_count">min_tx_count</span>](#miner-min_tx_count)~~ | Minimum number of transactions that must be in a block if we're going to<br>replace a pending block-commit with a new block-commit.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `0` |
| ~~[<span id="miner-only_increase_tx_count">only_increase_tx_count</span>](#miner-only_increase_tx_count)~~ | If true, requires subsequent mining attempts for the same block height to have<br>a transaction count >= the previous best attempt.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `false` |
| ~~[<span id="miner-pre_nakamoto_mock_signing">pre_nakamoto_mock_signing</span>](#miner-pre_nakamoto_mock_signing)~~ | Enables a mock signing process for testing purposes, specifically designed<br>for use during Epoch 2.5 before the activation of Nakamoto consensus.<br><br>When set to `true` and [mining_key](#miner-mining_key)  is provided, the miner<br>will interact with the `.miners` and `.signers` contracts via the stackerdb<br>to send and receive mock proposals and signatures, simulating aspects of the<br>Nakamoto leader election and block signing flow.<br><br>**Notes:**<br>- This is intended strictly for testing Epoch 2.5 conditions.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. | `false` (Should only default true if [mining_key](#miner-mining_key)  is set). |
| ~~[<span id="miner-subsequent_attempt_time_ms">subsequent_attempt_time_ms</span>](#miner-subsequent_attempt_time_ms)~~ | Time to wait (in milliseconds) for subsequent attempts to mine a block,<br>after the first attempt fails.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** milliseconds | `120_000` (2 minutes) |
| ~~[<span id="miner-target_win_probability">target_win_probability</span>](#miner-target_win_probability)~~ | The minimum win probability this miner aims to achieve in block sortitions.<br><br>This target is used to detect prolonged periods of underperformance. If the<br>miner's calculated win probability consistently falls below this value for a<br>duration specified by [underperform_stop_threshold](#miner-underperform_stop_threshold)  (after<br>an initial startup phase), the miner may cease spending in subsequent<br>sortitions (returning a burn fee cap of 0) to conserve resources.<br><br>Setting this value close to 0.0 effectively disables the underperformance check.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `0.0` |
| ~~[<span id="miner-unconfirmed_commits_helper">unconfirmed_commits_helper</span>](#miner-unconfirmed_commits_helper)~~ | Optional path to an external helper script for fetching unconfirmed<br>block-commits. Used to inform the miner's dynamic burn fee bidding strategy<br>with off-chain data.<br><br>If a path is provided, the target script must:<br>- Be executable by the user running the Stacks node process.<br>- Accept a list of active miner burnchain addresses as command-line arguments.<br>- On successful execution, print a JSON array representing `Vec<UnconfirmedBlockCommit>`<br>  (see `stacks::config::chain_data::UnconfirmedBlockCommit` struct) to stdout.<br>- Exit with code 0 on success.<br><br>Look at `test_get_unconfirmed_commits` in `stackslib/src/config/chain_data.rs`<br>for an example script.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode<br>and by the `get-spend-amount` cli subcommand. | `None` (feature disabled). |
| ~~[<span id="miner-underperform_stop_threshold">underperform_stop_threshold</span>](#miner-underperform_stop_threshold)~~ | The maximum number of consecutive Bitcoin blocks the miner will tolerate<br>underperforming (i.e., having a calculated win probability below<br>[target_win_probability](#miner-target_win_probability) ) before temporarily pausing mining efforts.<br><br>This check is only active after an initial startup phase (6 blocks past the<br>mining start height). If the miner underperforms for this number of<br>consecutive blocks, the `BlockMinerThread::get_mining_spend_amount` function<br>will return 0, effectively preventing the miner from submitting a block commit<br>for the current sortition to conserve funds.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode. | `None` (underperformance check is disabled). |
| ~~[<span id="miner-unprocessed_block_deadline_secs">unprocessed_block_deadline_secs</span>](#miner-unprocessed_block_deadline_secs)~~ | Amount of time (in seconds) to wait for unprocessed blocks before mining a new block.<br><br>**⚠️ DEPRECATED:** This setting is ignored in Epoch 3.0+. Only used in the neon chain mode.<br><br>**Units:** seconds | `30` |
| ~~[<span id="miner-wait_on_interim_blocks">wait_on_interim_blocks</span>](#miner-wait_on_interim_blocks)~~ | Amount of time while mining in nakamoto to wait in between mining interim blocks.<br><br>**⚠️ DEPRECATED:** Use `min_time_between_blocks_ms` instead. | `None` |



